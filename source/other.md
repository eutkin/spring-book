??? "Сейчас еще рано об этом говорить"
    Теперь определяем какие задачи будут выполняться быстро, а какие -- медленно:
    
    * Принимать задание и возможно делать его пре-обработку -- это быстрая операция, так как не требует 
    взаимодействие с внешними системами, либо это взаимодействие относительно быстрое
    (например, запрос в бд по индексу).
        
    * Расчет задания -- медленная операция, так как аналитические запросы выполняются на больших массивах
    данных. Это гораздо медленнее, чем делать запрос в базе по индексу (возможная операция в первой задаче) или 
    обработка в памяти.
        
    * Отправка результата задания по указанному адресу -- средняя по скорости операция. 
    Отправка POST запроса на внешний сервис
    происходит быстро, но здесь необходимо предусмотреть недоступность внешнего сервиса и связанные с этим сценарии. 
    
    В итоге получаем 3 функциональных модуля, каждый из которых выполняет свою независимую задачу с разной скоростью
    обработки.
    
    ??? tip "Совет" 
        Когда стоит выделять модуль в отдельный сервис?
        
        * имеет строго выделенную, независимую от других модулей зону ответственности. 
        
        * для выполнения функционала сервису необходимы только входные данные и сторонние системы: базы данных, брокеры
        сообщений, веб-сервисы.
        
        * есть требования к масштабируемости
    
        ??? "Термин"      
            Масштабируемость -- процесс, когда производительность системы пропорционально зависит от количества
            затраченных ресурсов. В бытовом плане чаще всего подразумевается горизонтальная машстабируемость, где
            под ресурсами имеется виду количество экземпляров сервиса            
    
    
    Представим, что нагрузка 
    на нашу систему стала резко расти. Первый модуль работает отлично. Но второй, рассчитывающий поступающие задания,
    не успевает обрабатывать возврастающий поток заданий и начинает захлебываться под нагрузкой. В итоге, задания
    не обрабатываются и производительность системы резко падает, так как второй модуль становится бутылочным горлышком. 
    
    Это происходит по причине неравномерной скорости работы модулей. Если скорость обработки у модулей отличаются
    на некоторую малую величину (давайте примем ее в 1 секунду. При условии, что скорость обработки в памяти занимает
    миллисекунды, то это довольно большая величина). 
    
    Для решения этой проблемы мы можем воспользоваться приемом [Замена прямых зависимостей на обмен сообщениями](archicture.md#_10).
    
    ??? example "Пример"
        Вы пришли в дикси за хлебом. Но на данный момент открыты только две кассы, а покупателей, желающих оплатить покупки
        и уйти, гораздо больше и их количество увеличивается. То есть нагрузка на кассы превышает их производительность.
        Для оплаты хлебушка, вы встаете в **очередь**
    
    
    Обмен сообщениями между модулями с разной скоростью работы мы организуем с помощью очередей. Одна очередь свяжет
    модули приема и расчета заданий, другая - модуль расчета и обработки результат заданий. 

??? "Пока рано"
    Очереди сообщений идут отдельной системой, так как они должны быть отказоустойчивыми и персистентными (чтобы в случае
    аварий не терять сообщения). 
    
    Определим стэк технологий для сторонних систем:
    
    * Брокер очередей. **RabbitMQ**. Популярный вариант для нагрузки ниже 10.000 сообщений/секунду. 
    * База данных для хранения заданий. **PostgreSQL/MySQL**. Два популярных варианта СУБД (системы управления базами данных)
    , если не требуется выполнять кучу 
    аналитических запросов. **PostgreSQL** сделан покачественней, имеет чуть больше возможностей и лучше документацию, но
    администрирование это просто кошмар. **MySQL** более дружелюбный, но функционал чуть ниже. По производительности 
    примерно одинаковы для простых запросов. Лучше выбирать тот вариант, который уже используется в компании.
    * База данных для аналитических запросов -- определяется тем, что уже есть. Так как обычно либо это **MS SQL/Oracle**,
    либо ClickHouse, либо Big Data (hadoop + spark/hive). Будем для простоты считать, что это jdbc совместимое хранилище, 
    поддерживающее стандарт SQL'92.         

??? "Пока рано"
    Теперь рассмотрим каждый модуль в отдельности.
    
    ### Модуль приема заданий
    
    Вспомним требования:
    
    > Система принимает на вход задание, в которой описано, что необходимо посчитать, за какой период и URL на 
    который необходимо отправить результат расчета
    
    > Задания должны быть привязаны к пользователю, которые их отправил, и храниться в каком-либо хранилище
    
    Попробуем проанализировать данное требование и подумать, что из него вытекает:
    
    1. Для приема заданий нам необходимо REST API.
    2. Раз есть пользователи, необходима авторизация
    3. Для хранения заданий необходима база данных
    4. Для отправки заданий на расчет необходим доступ к очередям
    
    Теперь продумаем алгоритм работы нашего сервиса (опять функциональная декомпозиция + порядок действий):
    
    1. Авторизовать пользователя
    2. Провалидировать задание
        * Если задание невалидно, выдать ошибку.
        * Если задание валидно, переходим на следующий этап.    
    3. Сохранить задание в базу данных
    4. Предусмотреть пре-обработку задания. Да, в требованиях этого нет, но скорее всего это потребуется, и надо заложить
    возможность для этого. 
    5. Отправить задание в очередь.
    
    Механизмы авторизации и валидации возложим на фреймворки (Spring Security, Spring MVC соответственно).
    
    Остается подумать над шагами с 3 по 5. 
    
    ??? tip "Совет* Тоже пока рано"
        Все шаги алгоритма можно разделить на две группы: 
        
        * Промежуточный
         
        * Терминальный
        
        Промежуточный шаг -- это шаг, чей результат используется дальше по алгоритму, терминальный же наоборот.
         
        Например, шаг валидации. Результат этого шага будет влиять на все остальные этапы работы системы. Это промежуточный
        шаг. 
        
        Шаг сохранения задания в базу с первого взгляда кажется терминальным, так как сохраненная задача нигде
        в этом алгоритме далее не используется. Но! надо принять во внимание такой результат как ошибка при сохранении. 
        Что делать, если база не ответчает? Давать обратную связь пользователю ("Произошла ошибка, попробуйте еще раз")?
        
        Если же факт возникновения ошибки выполнении не так важен, то шаг можно считать терминальным.
        
        ![a](img/arch_pr1.jpg) 
        
        Терминальные шаги можно выполнять параллельно с остальными шагами (в отдельном треде, в отдельном
        сервисе, вариантов много). Но только клиентский код, использующий интерфейс вашего терминального шага не должен 
        знать таких подробностей выполнения, т.е. Вызывающий код не должен сам запускать терминальный шаг в другом потоке.
    
    Каждый шаг алгоритма сервиса должен быть выполнен в виде интерфейса. Давайте попробуем.
    
    ##### Сохранение задания в базу данных
    
    Когда мы пишем интерфейсы для обозначения поведения системы, то можно пока не заморачиваться насчет структуры 
    обрабатываемых данных. Так как алгоритм обработки данных будет отражен в реализации, а на данном этапе мы вычисляем
    общие требования к программному модулю. 
    
    ```java
    import org.springframework.lang.NonNull; // (1)
    /**
        Интерфейс модуля сохранения задания в хранилище
     */
    public interface TaskSaver {
        
        /**
            Сохраняет задание
            
            @param task - задание (2)
            @return     - сохраненное задание (3)
            @throws NullPointerException - в случае если task равно {@literal null}
            @throws TaskSaveException - при ошибке сохранения (4) 
         */
        @NonNull // (5)
        Task save(@NonNull /* (6) */ Task task) throws TaskSaveException; // (7)
    }
    ``` 
    
    Пошаговый гайд о разработке интерфейсов можно посмотреть [тут](interface.md) 
        
    ##### Пре-обработка задания
    
    В требованиях у нас не стоит необходимость в обработке заданий. 
    Но само наличие такой обработки мы должны предусмотреть, так сказать, предугадать вектор изменений приложения.
    
    > Для многих это будет весьма спорным моментом, но я всегда стараюсь думать наперед и меня это не подводило. 
    Благодаря опциональным зависимостям, можно даже реализацию для этого интерфейса не писать, но самое его наличие
    может здорово нам помочь, не переписывая старый код.
    
    
    ```java
    /**
     * Обработчик задания. 
    */
    public interface TaskPreHandler {
    
         /**
         * Обрабатывает задание перед отправкой на расчет
         *
         * @param task задание
         * @return задание после обработки. Если обработка неприменима, то возвращается исходное задание
         * @throws TaskHandlerException ошибка обработки
         */
        Task apply(Task task) throws TaskHandlerException;
        
    }
    ```