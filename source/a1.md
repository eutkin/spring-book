# Архитектура на практике

## Введение

Перед прочтением данной главы, ознакомьтесь с [главой про архитектуру](archicture.md), а также c
[Пошаговым гайдом о разработке интерфейсов](interface.md).

Здесь же, мы разберем на практике принципы и приемы по построению грамотного дизайна на примере нескольких систем.

Так как данная книга по спрингу, то и реализации у нас тоже будут на спринге. Но мы постараемся также рассмотреть 
и аналоги (но не Java EE, от которой отказались даже родители)

Рассмотрим такую систему:

Система для расчета некоторых показателей по имеющимся данным в аналитических целях.   

Требования: 

* Система принимает на вход задание, в которой описано, что необходимо посчитать, за какой период и URL на 
который необходимо отправить результат расчета

* Задания должны быть привязаны к пользователю, которые их отправил, и храниться в каком-либо хранилище

* После расчета на указанный в задаче URL должен быть отправлен результат задания

* Должна быть поддержка нескольких типов заданий

Все примеры кода можно будет посмотреть в проекте на [github](https://github.com/eutkin/archicture).
    
## Декомпозиция

Первым шагом при решении любой задачи является декомпозиция: разбиение большой задачи на задачи поменьше. 

Начнем с [иерархической декомпозиции](archicture.md#_5).

Наша система должна считать задания и желательно давать 
пользователю какую-либо обратную связь. Создадим интерфейс логики системы в целом:

```java
/**
* Калькулятор заданий в целом. Принимает задание на расчет 
* и отдает обратную связь (сообщение)
*/
public interface TaskCalculatorFacade {
    
    @NonNull Feedback calculate(@NonNull Task task);
}
```

Это будет главный интерфейс для доступа к нашей системе или, другими словами, [Фасад](archicture.md#_8). 

Теперь разобьем основную задачу на задачи поменьше. Для этого применим [функциональную декомпозицию](archicture.md#_6). 

Давайте определим независисые друг от друга задачи, которые должна выполнять система, исходя из требований:

* Система должна принимать задания и где-то хранить их с привязкой к пользователю. Эти задачи стоят вместе, потому
что отправлять на расчет необходимо уже сохраненное задание.   

* Система должна рассчитывать задания

* Система должна отправлять результат задания на внешний сервис


Каждую такую задачу мы выделяем в отдельный модуль. В итоге, мы получаем следующие функциональные модули:

* Модуль пред-обработки заданий (сохранение)

* Модуль расчета заданий

* Модуль обработки результата задания


Для каждого модуля напишем интерфейс. 

Получаем:

```java
import org.springframework.lang.NonNull;

/**
* Модуль пред-обработки заданий (сохранение)
* 
*/
public interface TaskPreHandler {
    
    /**
    * Обработывает задание. Способ обработки зависит от реализации. 
    * 
    * {@link Task} - модель представления задания   
    * 
    * @param task задание. 
    * @return контейнер для задания. Необходим, если вместо с задачей 
    * надо передать дополнительную информацию
    * @throws TaskHandleException ошибка при обработке
    */
    @NonNull
    Task handle(@NonNull Task task) throws TaskHandleException; 
}
```

```java
/**
* Модуль расчета заданий
*/
import org.springframework.lang.NonNull;

public interface TaskCalculator {
    
    /**
    * Расчитывает задание
    * @param task задание
    * @return результат задания
    * @throws CalculateException ошибка при расчете задания
    */
    @NonNull
    Result calculate(@NonNull Task task) throws CalculateException; 
}
```      
    
```java
import org.springframework.lang.NonNull;

/**
* Модуль обработки результата задания
*/
public interface ResultHandler {
    
    /**
    * Обрабатывает результат расчета задания
    * @param result результат расчета
    * @return сообщение об успешной обработки результата
    * @throws ResultHandleException ошибка при обработке результата
    */
    ResultInfo handle(@NonNull Result result) throws ResultHandleException;
    
}
```    
    
Важно замечание. При проектировании системы, как может заметить внимательный читатель, мы не обращали внимание
на структуру обрабатываемых данных. В интерфейсах выше пока стоят модели (Data Transfer Object или DTO) без какой-либо
структуры, так как структура данных не играет роли. Структура данных влиет прежде всего на реализации. 
   

    
    
    
    
    
    
## Требования или немного лирики
 
Требования -- это головная боль разработчика. Почему? Потому что явление, когда кто-то может внятно и подробно объяснить,
что он, собственно, от вас хочет, довольно редкое. 

Как в теории:

* Аналитик (или менеджер) работает с клиентом и выясняет, чего хочется клиенту. Как он это делает? Не наша головная боль,
а его. 

* Аналитик (или менеджер) передает собранные требования системному аналитику, который переводит их с языка гуманитариев
на язык инженеров. Он формализует все требования и по итогу мы получаем некий документ (user story) с их подробным 
описанием.

* Тимлид разбивает требования на задачи и раскидывает по разрабам, в итоге у разраба есть четкие требования, что 
от него требуется сделать. 

Как в жизни:

* "Нам надо расчитать такие-то характеристики, как их рассчитать спроси у Марины, и сделай еще, чтобы результат
на почту приходил, и да, надо сделать какое-нибудь REST API еще. И давай быстрее, нам вчера надо"

 И ты 3 дня ходишь выясняешь, а что все-таки требуется и в каком виде, а в итоге выясняется, что Марина в отпуске и
 больше никто про эти характеристики не знает, что хотели совсем другое и вообще это понадобится через полгода.
 
Что с этим делать? Либо требовать, чтобы формулировали хотя бы самые основные требования, либо увольняться, потому что
по итогу все равно ты останешься виноватым (либо валить все на тимлида).

Ладно, ближе к делу.    

Требования бывают явные и неявные. С явными все понятно -- "Если пользователь делает действие А, то должно происходить
действие Б и В". То есть они явно где-то заданы: в тикете, в user story, в документации. 

С неявными сложнее. Неявные требования -- это хотелки, которые подразумевается. Например, нигде где явно не написано, 
что пользователю надо отдавать описание ошибки, если таковая произошла. Но она подразумевается. 

Принцип работы с неявными требованиями заключается, что некоторые вещи довольно стандартны и можно взять на вооружение
алгоритмы из имеющихся сервисов, та же обработка ошибок. Либо говорить, что этого не было в требованиях, поэтому этого 
и нет. Но здесь, как и везде, очень важно соблюдать баланс между здравым смыслом и идиотией.  

Пример неявных требований из тз, приведенного в начале статьи: необходимо описать формат входных-выходных данных, так 
как в требованиях это не прописано. Или что делать, если задача не может быть рассчитана?

В случае с неявными требованиями очень важно вести какую-нибудь документацию по проекту, потому что с большой долей
вероятностью она вам понадобится. Если вы приняли какое-то решение по неявному требованию (делаем вот так), то желательно
согласовать его с заказчиком, вежливо, но жестко. Формальное согласие потом здорово вам поможет после разработки и снимет
с вам любую ответственность. 

Теперь перейдем непосредственно к проектированию    