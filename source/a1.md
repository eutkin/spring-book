# Архитектура на практике

## Введение

Перед прочтением данной главы, ознакомьтесь с [главой про архитектуру](archicture.md), а также c
[Пошаговым гайдом о разработке интерфейсов](interface.md).

Здесь же мы разберем на практике принципы и приемы по построению грамотного дизайна на примере нескольких систем.

Так как данная книга по спрингу, то и реализации у нас тоже будут на спринге. Но мы постараемся также рассмотреть 
и аналоги (но не Java EE, от которой отказались даже родители)

Рассмотрим такую задачу:

Есть большой объем данных по продажам мобильных устройств в Китае, который хранится  в колоночкой базе данных 
с поддержкой SQL`92. Нашим клиентам хотелось бы получать различные статистики по продажам, например, количество
проданных телефонов определенной марки (например, Huawei) или отношение проданных телефонов с вырезом на экране 
к телефонам без выреза в %. 

Требования: 

* Система принимает на вход задание через Web API, 
в которой описано, что необходимо посчитать, за какой период и URL, на 
который необходимо отправить результат расчета

* Задания должны быть привязаны к пользователю, которые их отправил, 
и храниться в каком-либо хранилище

* После расчета на указанный в задаче URL должен быть отправлен результат задания

* Должна быть поддержка нескольких типов заданий

## Трехслойная архитектура

Большинство приложений (модулей) строятся по трехслойной архитектуре:

![3layer](img/arch_pr2.png)

Иногда ее называют тортик-архитектура. Принципы:

* Приложение делится на 3 слоя
* Каждый слой должен зависеть только от слоя на один уровень ниже (но только строго на один уровень ниже, т.е. 
**Presentation Layer** (servlet) зависит от **Business Layer**, но ничего знает про **Data Access Layer** (repository)).
* Каждый слой ничего не должен знать про слои выше.

Виды слоев: 

* **Presentation Layer** -- слой для взаимодействия с пользователем. Данный слой ответственнен прием и отдачу данных,
их преобразование в термины вашей системы. Например, пользователь присылает вам запрос с json-сообщением, а слой 
представления должен преобразовать этот запрос в объект `Task`. И наоборот, данный слой конвертирует сущности вашей
системы в формат, удобный для пользователя (тот же самый json, html страничка и так далее.). 

    ???+ danger "Важно"
        Слой представления не должен содержать в себе логики. Он отвечает только за конвертацию входных данных в термины
        вашей системы и наоборот. Любая логика запрещена. Это правило следует из принципа Единой ответственности.

* **Business Layer** -- слой бизнес-логики. Самый главный слой вашей системы. Инкапсулирует логику работы приложения. 

* **Data Access Layer** -- слой взаимодействия с хранилищем данных. Хранилищем данных может выступать не только СУБД,
но и веб-сервисы, файлы. В этом слое реализованы атомарными операции с данными (CRUD). Если на Data Access Layer вам
хочется сделать в одном методе несколько вызовов к бд, это означает, что вашему коду место на слой выше. 

При проектировании информационной системы на первом этапе сосредоточится на слое бизнес-логике (Business Layer).
    
## Декомпозиция

Первым шагом при решении любой задачи является декомпозиция: разбиение большой задачи на задачи поменьше. 

### Модули первого уровня

Начнем с [иерархической декомпозиции](archicture.md#_5).

Наша система должен считать задания и отправлять результаты на URL, указанный в задании. Давайте порисуем в блокнотике:

![calc](img/arch_pr3.png)

Так как мы принимаем запрос по http, а этот протокол подразумевает получение ответа на каждый запрос, 
то нам пользователю необходимо отдать какой-либо ответ, например, задача принята на расчет или произошла ошибка.
Поэтому немного модернизируем нашу схему:

![calc1](img/arch_pr4.png)

### Модули второго уровня

Далее разобьем большой модуль *Calculator* на несколько модулей (задач) поменьше.  

Для этого применим [функциональную декомпозицию](archicture.md#_6). 

Давайте определим независисые друг от друга задачи, которые должна выполнять система, исходя из требований:

* Система должна хранить задания с привязкой к пользователю. 

* Система должна рассчитывать задания

* Система должна отправлять результат задания на внешний сервис

Каждой задаче будет соответствовать свой модуль. Нарисуем новую схему: 

![calc2](img/arch_pr5.png)

Каждую такую задачу мы выделяем в отдельный модуль. В итоге, мы получаем следующие функциональные модули:

* Модуль пред-обработки заданий (сохранение) (**Task Pre-Handler**)

* Модуль расчета заданий (**TaskCalculator**)

* Модуль обработки результата задания (**ResultHandler**)

А вот дальше уже проблема. Если три модуля выше были очевидны из требований, то как разбивать дальше уже плохо 
понятно. В таком случае, что мы говорим дальнейшей декомпозиции? Не сегодня. И переходим к практике. 

???+ tip "Совет"
    Если при декомпозиции вы не можете разбить задачу на более мелкие, оставьте ее единым целом. При написании 
    реализации появится ясность, как разбивать дальше.

Каждому модулю должен соответствовать интерфейс с описание входных и возвращаемых данных, ограничений, описания 
возвращаемых значений, исключений и так далее. 

Модуль *Calculator* состоит из нескольких модулей поменьше. Вопрос в том, делать ли для него интерфейс? Да, так как
это полноценный модуль, с входными-выходными данными. Это и есть паттерн [Фасад](archicture.md#_8).  

Приступим к написанию интерфейса. Для этого вспомним нашу схему:

![calc1](img/arch_pr4.png)

Как видно из схемы, мы принимаем Task, возвращаем Feedback. Связь с внешним сервисом у нас будет инкапсулирована
внутри нашего модуль *Calculator*. Немного кода:

```java
import org.springframework.lang.NonNull;

/**
* Калькулятор заданий в целом. Принимает задание на расчет 
* и отдает обратную связь (сообщение)
*/
public interface TaskCalculatorFacade {
    
    @NonNull Feedback calculate(@NonNull Task task);
}
```

Это будет главный интерфейс для доступа к нашей системе (не забываем, что это называется [Фасад](archicture.md#_8)). 

Теперь опустимся на уровень ниже и напишем интерфейсы для модулей поменьше, согласно нашей схеме:

![calc2](img/arch_pr5.png)
 

Получаем:

```java
import org.springframework.lang.NonNull;

/**
* Модуль пред-обработки заданий (сохранение)
* 
*/
@FunctionalInterface // контроллирует, что интерфейс имеет только один недефолтный метод. 
// Это небходимо, чтобы мы могли писать реализации интерфейсы в виде лямбды 
public interface TaskPreHandler {
    
    /**
    * Обработывает задание. Способ обработки зависит от реализации. 
    * 
    * {@link Task} - модель представления задания   
    * 
    * @param task задание. 
    * @return контейнер для задания. Необходим, если вместо с задачей 
    * надо передать дополнительную информацию
    * @throws TaskHandleException ошибка при обработке
    */
    @NonNull
    Task handle(@NonNull Task task) throws TaskHandleException; 
}
```

```java
import org.springframework.lang.NonNull;

/**
* Модуль расчета заданий
*/
@FunctionalInterface 
public interface TaskCalculator {
    
    /**
    * Расчитывает задание
    * @param task задание
    * @return результат задания
    * @throws CalculateException ошибка при расчете задания
    */
    @NonNull
    Result calculate(@NonNull Task task) throws CalculateException; 
}
```      
    
```java
import org.springframework.lang.NonNull;

/**
* Модуль обработки результата задания
*/
@FunctionalInterface 
public interface ResultHandler {
    
    /**
    * Обрабатывает результат расчета задания
    * @param result результат расчета
    * @throws ResultHandleException ошибка при обработке результата
    */
    void handle(@NonNull Result result) throws ResultHandleException;
    
}
```    
    
???+ danger "Важно"
    При проектировании системы, как может заметить внимательный читатель, мы не обращали внимание
    на структуру обрабатываемых данных. В интерфейсах выше пока стоят модели (Data Transfer Object или DTO) без какой-либо
    структуры, так как структура данных не играет роли. Структура данных влиет прежде всего на реализации. 
    
Напишем для примера реализацию `TaskPreHandler` с использованием **Data Access Layer**:

```java
@Service
public class TaskSaver implements TaskPreHandler {
    
    // это интерфейс из Data Access Layer
    private final TaskRepository taskRepository;
    
    public TaskSaver(TaskRepository taskRepository) {
        this.taskRepository = Objects.requireNonNull(taskRepository);
    }
    
    @NonNull
    public Task handle(@NonNull Task task) throws TaskHandleException {
        try {
            return taskRepository.save(task);
        } catch (PersistenceException ex) {
            throw new TaskHandleException(ex);
        }
    }
}
```    
   
После декомпозиции большого модуля, мы можем написать реализацию для его интерфейса. которая объединит через композицию
модули поменьше:

```java
public class TaskCalculatorFacadeImpl implements TaskCalculatorFacade {

    private final TaskPreHandler taskPreHandler;

    private final TaskCalculator taskCalculator;

    private final ResultHandler resultHandler;

    public TaskCalculatorFacadeImpl(
            TaskPreHandler taskPreHandler,
            TaskCalculator taskCalculator,
            ResultHandler resultHandler
    ) {
        this.taskPreHandler = Objects.requireNonNull(taskPreHandler);
        this.taskCalculator = Objects.requireNonNull(taskCalculator);
        this.resultHandler =  Objects.requireNonNull(resultHandler);
    }

    public Feedback calculate(Task task) {
        try {

            Task handledTask = taskPreHandler.handle(task);
            Result result = taskCalculator.calculate(handledTask);
            resultHandler.handle(result);
            return Feedback.success();
        } catch (CalculateException | TaskHandleException | ResultHandleException e) {
            return Feedback.error(e);
        }
    }
}
```

Далее пишем реализации для оставшихся интерфейсов. 
 
### Модули третьего уровня 
 
В качестве примера дальнейшей декомпозиции возьмем `TaskCalculator`. И идем известным путем. У нас есть большая 
задача (расчет заданий), которую надо разбить на несколько маленьких. Начинаем снова рассуждать. 

Данные по продажам лежат в базе с поддержкой SQL. Значит получать выборку для расчета или уже готовые значения
мы можем через SQL. 

Попытаемся разобраться, что нам будет необходимо для реализации калькулятора:

* SQL Query Generator. Модуль, который будет генерировать sql запрос на основе задания (`Task`)
* SQL Executor. Модуль, который будет выполнять sql запрос и возвращать нам какие-то данные (либо выборку, либо 
рассчитанные значения).   
* SQL ResultSet Handler. Модуль обработки результа запроса

Продолжаем рисовать и дополняем нашу схему:

![calc6](img/arch_pr6.png)

Набросаем интерфейсы:

```java
/**
* Модуль, который будет генерировать sql запрос на основе задания (`Task`)
*/
@FunctionalInterface
public interface SqlQueryGenerator {
    
    /**
    * Генерирует sql запрос для задания
    * @param task задание
    * @return sql запрос
    * @throws QueryGenerateException если для задания невозможно сгенерировать валидный sql запрос
    */
    @NonNull
    String generate(@NonNull Task task) throws QueryGenerateException;
} 
```

Для простоты интерфейсы остальных модулей опустим.

Пишем реализацию для `TaskCalculator`:

```java
public class SqlTaskCalculator implements TaskCalculator {
    
    private final SqlQueryGenerator sqlQueryGenerator;
    private final SqlExecutor sqlExecutor;
    private final SqlResultSetHandler resultSetHandler;
    
    public SqlTaskCalculator(
                SqlQueryGenerator sqlQueryGenerator,
                SqlExecutor sqlExecutor,
                SqlResultSetHandler resultSetHandler
    ) {
        this.sqlQueryGenerator = Objects.requireNonNull(sqlQueryGenerator);
        this.sqlExecutor = Objects.requireNonNull(sqlExecutor);
        this.resultSetHandler = Objects.requireNonNull(resultSetHandler);
    }
    
    @NonNull
    public Result calculate(@NonNull Task task) throws CalculateException {
        try {
            String sql = sqlQueryGenerator.generate(task);
            SqlResultSet resultSet = sqlExecutor.execute(sql);
            Result result = resultSetHandler.handle(resultSet);
        } catch (QueryGenerateException /* | Исключения других интерфейсов */ ex) {
            throw new CalculateExecption(ex);
        }
    } 
}
```

И так шаг за шагом доводим систему до готовности.

После того, как мы закончили со слоем бизнес-логики, то прикручиваем остальные слои:

**Presentation Layer** :

```java
@Controller
@RequestMapping("/task")
public class TaskController {
    
    private final TaskCalculatorFacade calculator;
    
    public TaskController(TaskCalculatorFacade calculator) {
        this.calculator = Objects.requireNonNull(calculator);
    }
    
    // Spring MVC сам преобразует json сообщение в DTO и обратно
    @PostMapping
    public ResponseEntity<Feedback> sendTask(@RequestBody Task task) {
        Feedback feedback = calculator.calculate(task);
        // по хорошему для разных фидбэков нужен разный стастус, 
        // но для простоты пока пусть будет так
        return ResponseEntity.ok(feedback); 
    }
}
```  

### Резюме

Декомпозиция является основным приемом при проектировании систем. Процесс декомпозиции можно представить как рекурсивную
задачу, принимающую на вход один большой модуль и возвращающую древовидную структуру модулей. 

1. Модуль можно разбить хотя бы на две независимые задачи?
2. Если нет, то оставляем как есть
3. Если да, то вернись к шагу 1.

После завершении декомпозиции и написания необходимых интерфейсов и реализаций, мы получаем уже готовую систему.
Гибкую и расширяемую, так как явные зависимости у нас отсутствуют. 

??? tip "Совет"
    Если вы не можете разбить модуль, но вам кажется, что его можно разбить, просто не знаете как -- напишите
    его реализацию (вам ведь все равно придется ее писать, ведь так). И затем проанализируйте эту реализацию, можно
    ли ее разбить на модули поменьше. 
    
??? tip "Совет"
    Не переживайте, если в процессе написания реализаций вы поняли, что декомпозировали неправильно. Пока система только
    пишется, можно еще все переиграть. **Но!** это работает только на начальных этапах и на маленьких масштабах,
    например, когда вы пишете не очень большой модуль. Крупные модули надо проектировать очень ответственно, продумывать
    все мелочи, иначе ваш проект можно будет выкидывать, так как его поддержка будет дороже, чем написать заново.    

## Расширение функционала через композитные бины

Для мониторинга калькулятора неплохо было бы добавить метрику, которая учитывала бы количество поступивших заданий. 
Возникает вопрос, как добавить такой функционал в существующую систему. Как мы помним, нам нельзя менять существующий
код (прицип **Open-Close** или принцип **Открытости-Закрытости**). Поэтому воспользуемся таким паттерном как 
[Chain of Responsibility](https://refactoring.guru/ru/design-patterns/chain-of-responsibility). Он же композитный бин,
так как внутри состоит из нескольких бинов.

```java
@Configuration
public class SomeConfiguration {
    
   @Bean
   @Primary // это аннотация означает, что если есть несколько бинов, реализаций одного интерфейса, 
   // то при использовании @Autowired будет внедрен бин, помечененный аннотацией @Primary.
   public TaskPreHandler compositeTaskPreHandler(
           @Autowired(required = false) List<TaskPreHandler> handlers
   ) {
       Stream<TaskPreHandler> handlerStream = handlers == null ? 
                       Stream.empty() : handlers.stream();
       BinaryOperator<TaskPreHandler> operator = (handler, nextHandler) -> 
               task -> nextHandler.handle(handler.handle(task));
       // сложный кусок. Здесь мы все обработчики объединяем в 
       // одну длинную последовательную цепочку.      
       return handlerStream
               .reduce(task -> task, operator);
   }
}
```

Теперь для добавления нового обработчика для мониторинга, мы просто создаем еще один бин:

```java
@Component
public class MonitoringTaskCounter implements TaskPreHandler {
    
    private final CounterService counterService;
    
    public MonitoringTaskCounter(CounterService counterService) {
        this.counterService = Objects.requireNonNull(counterService);
    }
    
    @NonNull
    public Task handle(@NonNull Task task) throws TaskHandleException {
        counterService.increment("counter.task.input");
        return task;
    }
}
```

В итоге, сначала будет выполнен TaskSaver, а затем MonitoringTaskCounter. Или наоборот, так как порядок мы не задали.
Порядок выполнения можно задать через аннотацию @Order/интерфейс PriorityOrdered | Ordered. 

Тоже самое можно применить и для `ResultHandler`, если нам понадобится больше обработок. 


## Разделяй и масштабируй

### Проблематика

С ростом нагрузки на нашу систему, ее производительность начинает деградировать. Особенно это чувствуется при пиковых
нагрузках, например, если весь день ваша система была под нагрузкой 200 запросов в секунду, то с 19.00 по 20.00 нагрузка
увеличивается до 1000 запросов в секунду. 

Чтобы система могла переваривать нагрузку, она должна уметь масштабироваться.

???+ "Масштабирование"
    **Вертикальное масштабирование** -- увеличение производительности каждого компонента системы с целью повышения 
    общей производительности. 
    Масштабируемость в этом контексте означает возможность заменять в существующей вычислительной системе компоненты 
    более мощными и быстрыми по мере роста требований и развития технологий. Это самый простой способ масштабирования, 
    так как не требует никаких изменений в прикладных программах, работающих на таких системах.
    **Горизонтальное масштабирование** -- разбиение системы на более мелкие структурные компоненты и разнесение их 
    по отдельным физическим машинам (или их группам), и (или) увеличение количества серверов, параллельно выполняющих 
    одну и ту же функцию. Масштабируемость в этом контексте означает возможность добавлять к системе новые узлы, серверы, 
    процессоры для увеличения общей производительности. Этот способ масштабирования может требовать внесения изменений 
    в программы, чтобы программы могли в полной мере пользоваться возросшим количеством ресурсов.
                                             

Давайте вернемся чуть назад и снова посмотрим на [модули второго уровня](a1.md#_6):

![2level](img/arch_pr5.png)

Проанализуем производительность каждого из модулей и системы в целом. Так как делать замеры нам лень, то давайте
оценим производительность модулей эмпирическим путем. Измерять производительность будет от 1 до 5, где 1 -- очень 
быстро, 10 -- очень медленно.

Для этого надо вспомнить (или узнать) уровни производительности различных подсистем компьютера, 

6. Сеть. Самое медленное взаимодействие
5. Чтение файла с жесткий диск.
4. Бд. Выполнение аналитического запроса 
3. Бд. Чтение по уникальному ключу
2. Память
1. CPU

Перейдем к анализу производительности каждого модуля

* **TaskPreHandler**. В этом модуле у нас есть сохранение в базу данных и, возможно, какая-то обработка в памяти. 
Так как объем сохраняемых данных у нас маленький, то сохранение не будет занимать много времени. **Производительность: 
2**

* **TaskCalculator**. В этом модуле будет выполняться аналитические запросы в базу, расчеты в памяти (обработка 
результата запроса). **Производительность: 7**

* **ResultHandler**. Сам процесс отправки результата на внешний сервис довольно быстрый (но зависит от объема, который
мы отправляем), но здесь важно не забыть проблемы, когда внешний сервис недоступен или произошла какая-то сетевая ошибка.
А, следовательно, нам надо сделать еще одну попытку отправка через некоторый промежуток времени.
**Производительность: 10**

Производительность системы в целом всегда равна производительности самой медленной части, которая называется 
бутылочное горлышко. На практике это означает, что какую быструю обработку вы бы не делали, какую бы быструю базу не 
купили, ваша производительность будет равна производительности **ResultHandler**.  С низкой производительностью мы 
не можем переварить нагрузку, особенно если она вдруг резко возрастет (например, из-за пика активности или Хабра-
эффекта).

### Решение

Какие пути увеличения производительности мы видим? 

* Увеличить производительность _бутылочного горлышка_. Например, сократить временные задержки. Либо сделать систему 
многопоточной и одновременно отправлять несколько результатов.

    То есть пойти путем оптимизации и вертикального масштабирования. 
    Да, это немного исправит ситуацию, но до определенного 
    предела, причем не очень большого. Количество тех же тредов сильно ограничено количеством ядер процессора и бесконечно
    увеличивать количество тредов мы не можем. 

* Увеличить количество экземлляров **ResultHandler** с возможностью их запуска на нескольких серверах сразу. Иными 
словами горизонтально машстабировать модуль. С таким типом масштабирования мы можем в теории иметь сколько угодно
экземляров модуля **ResultHandler**.

Второй способ выглядит просто здоровским, но мы уже написали систему, нам теперь все переделывать? 

![mor](img/arch_pr7.jpg)

В чем идея? Суть такова. В монолитном приложении как происходит взаимодействие? Мы вызываем метод у объекта, который
выполняет свою часть работы. В сервисной архитектуре мы вызываем метод, который отправляет команду другому сервису
сделать часть работы. А что если вместо реального объекта, который перехватывает вызов метода в монолите и вместо
выполнения бизнес-логики будет отправлять команду на другой сервис? То есть для клиентского кода мы просто вызываем
метод у объекта, даже не подозревая, что его работу выполняет не он сам, а другой сервис:

```java
public class ResultHandlerWebProxy implements ResultHandler {

    private final RestOperations webClient;

    // специальный класс, позволяющий повторять выполнение кода, если он выкинул определенную ошибку
    private RetryOperations retry;

    private final URI resultHandlerServiceUrl;

    public ResultHandlerWebProxy(RestOperations webClient, URI resultHandlerServiceUrl) {
        this.webClient = webClient;
        this.resultHandlerServiceUrl = resultHandlerServiceUrl;
    }

    @Override
    public ResultInfo handle(Result result) throws ResultHandleException {
        if (retry == null) {
            return send(result).getBody();
        }
        return retry.execute((RetryCallback<ResultInfo, RestClientException>) context -> {
            ResponseEntity<ResultInfo> response = send(result);
            HttpStatus statusCode = response.getStatusCode();
            if (statusCode.is2xxSuccessful()) {
                return response.getBody();
            }
            if (statusCode.is4xxClientError()) {
                throw new IncorrectRequestRestClientException();
            }
            throw new RestClientException(statusCode.getReasonPhrase());
        });
    }

    private ResponseEntity<ResultInfo> send(Result result) {
        return webClient
                .postForEntity(resultHandlerServiceUrl, result, ResultInfo.class);
    }

    public void setRetry(RetryOperations retry) {
        this.retry = retry;
    }
}
```
    
## Требования или немного лирики
 
Требования -- это головная боль разработчика. Почему? Потому что явление, когда кто-то может внятно и подробно объяснить,
что он, собственно, от вас хочет, довольно редкое. 

Как в теории:

* Аналитик (или менеджер) работает с клиентом и выясняет, чего хочется клиенту. Как он это делает? Не наша головная боль,
а его. 

* Аналитик (или менеджер) передает собранные требования системному аналитику, который переводит их с языка гуманитариев
на язык инженеров. Он формализует все требования и по итогу мы получаем некий документ (user story) с их подробным 
описанием.

* Тимлид разбивает требования на задачи и раскидывает по разрабам, в итоге у разраба есть четкие требования, что 
от него требуется сделать. 

Как в жизни:

* "Нам надо расчитать такие-то характеристики, как их рассчитать спроси у Марины, и сделай еще, чтобы результат
на почту приходил, и да, надо сделать какое-нибудь REST API еще. И давай быстрее, нам вчера надо"

 И ты 3 дня ходишь выясняешь, а что все-таки требуется и в каком виде, а в итоге выясняется, что Марина в отпуске и
 больше никто про эти характеристики не знает, что хотели совсем другое и вообще это понадобится через полгода.
 
Что с этим делать? Либо требовать, чтобы формулировали хотя бы самые основные требования, либо увольняться, потому что
по итогу все равно ты останешься виноватым (либо валить все на тимлида).

Ладно, ближе к делу.    

Требования бывают явные и неявные. С явными все понятно -- "Если пользователь делает действие А, то должно происходить
действие Б и В". То есть они явно где-то заданы: в тикете, в user story, в документации. 

С неявными сложнее. Неявные требования -- это хотелки, которые подразумевается. Например, нигде где явно не написано, 
что пользователю надо отдавать описание ошибки, если таковая произошла. Но она подразумевается. 

Принцип работы с неявными требованиями заключается, что некоторые вещи довольно стандартны и можно взять на вооружение
алгоритмы из имеющихся сервисов, та же обработка ошибок. Либо говорить, что этого не было в требованиях, поэтому этого 
и нет. Но здесь, как и везде, очень важно соблюдать баланс между здравым смыслом и идиотией.  

Пример неявных требований из тз, приведенного в начале статьи: необходимо описать формат входных-выходных данных, так 
как в требованиях это не прописано. Или что делать, если задача не может быть рассчитана?

В случае с неявными требованиями очень важно вести какую-нибудь документацию по проекту, потому что с большой долей
вероятностью она вам понадобится. Если вы приняли какое-то решение по неявному требованию (делаем вот так), то желательно
согласовать его с заказчиком, вежливо, но жестко. Формальное согласие потом здорово вам поможет после разработки и снимет
с вам любую ответственность. 

Теперь перейдем непосредственно к проектированию    