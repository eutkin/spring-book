# Архитектура на практике

## Введение

Перед прочтением данной главы, ознакомьтесь с [главой про архитектуру](archicture.md).

Здесь же, мы разберем на практике принципы и приемы по построению грамотного дизайна на примере нескольких систем.

Так как данная книга по спрингу, то и реализации у нас тоже будут на спринге. Но мы постараемся также рассмотреть 
и аналоги (но не Java EE, от которой отказались родители)

Рассмотрим такую систему:

Система для расчета некоторых показателей по имеющимся данным в аналитических целях.   

Требования: 

* Система принимает на вход задание, в которой описано, что необходимо посчитать, за какой период и URL на 
который необходимо отправить результат расчета

* Задания должны быть привязаны к пользователю, которые их отправил, и храниться в каком-либо хранилище

* После расчета на указанный в задаче URL должен быть отправлен результат задания

* Должна быть поддержка нескольких типов заданий
    
## Требования

Требования -- это головная боль разработчика. Почему? Потому что явление, когда кто-то может внятно и подробно объяснить,
что он, собственно, от вас хочет, довольно редкое. 

Как в теории:

* Аналитик (или менеджер) работает с клиентом и выясняет, чего хочется клиенту. Как он это делает? Не наша головная боль,
а его. 

* Аналитик (или менеджер) передает собранные требования системному аналитику, который переводит их с языка гуманитариев
на язык инженеров. Он формализует все требования и по итогу мы получаем некий документ (user story) с их подробным 
описанием.

* Тимлид разбивает требования на задачи и раскидывает по разрабам, в итоге у разраба есть четкие требования, что 
от него требуется сделать. 

Как в жизни:

* "Нам надо расчитать такие-то характеристики, как их рассчитать спроси у Марины, и сделай еще, чтобы результат
на почту приходил, и да, надо сделать какое-нибудь REST API еще. И давай быстрее, нам вчера надо"

    И ты 3 дня ходишь выясняешь, а что все-таки требуется и в каком виде, а в итоге выясняется, что Марина в отпуске и
    больше никто про эти характеристики не знает, что хотели совсем другое и вообще это понадобится через полгода.
    
Что с этим делать? Либо требовать, чтобы формулировали хотя бы самые основные требования, либо увольняться, потому что
по итогу все равно ты останешься виноватым (либо валить все на тимлида).

Ладно, ближе к делу.    

Требования бывают явные и неявные. С явными все понятно -- "Если пользователь делает действие А, то должно происходить
действие Б и В". То есть они явно где-то заданы: в тикете, в user story, в документации. 

С неявными сложнее. Неявные требования -- это хотелки, которые подразумевается. Например, нигде где явно не написано, 
что пользователю надо отдавать описание ошибки, если таковая произошла. Но она подразумевается. 

Принцип работы с неявными требованиями заключается, что некоторые вещи довольно стандартны и можно взять на вооружение
алгоритмы из имеющихся сервисов, та же обработка ошибок. Либо говорить, что этого не было в требованиях, поэтому этого 
и нет. Но здесь, как и везде, очень важно соблюдать баланс между здравым смыслом и идиотией.  

Пример неявных требований из тз, приведенного в начале статьи: необходимо описать формат входных-выходных данных, так 
как в требованиях это не прописано. Или что делать, если задача не может быть рассчитана?

В случае с неявными требованиями очень важно вести какую-нибудь документацию по проекту, потому что с большой долей
вероятностью она вам понадобится. Если вы приняли какое-то решение по неявному требованию (делаем вот так), то желательно
согласовать его с заказчиком, вежливо, но жестко. Формальное согласие потом здорово вам поможет после разработки и снимет
с вам любую ответственность. 

Теперь перейдем непосредственно к проектированию    
    
## Декомпозиция

Первым шагом при решении любой задачи является декомпозиция: разбиение большой задачи на задачи поменьше. 

Проще всего начать с [функциональной декомпозиции](archicture.md#_7). Попробуем определить независисые друг от друга 
задачи, которые должна выполнять система, исходя из требований:

* Система должна принимать задания и где-то хранить их с привязкой к пользователю. Эти задачи стоят вместе, потому
что отправлять на расчет необходимо уже сохраненное задание.   

* Система должна рассчитывать задания

* Система должна отправлять результат задания на внешний сервис

??? "Сейчас еще рано об этом говорить"
    Теперь определяем какие задачи будут выполняться быстро, а какие -- медленно:
    
    * Принимать задание и возможно делать его пре-обработку -- это быстрая операция, так как не требует 
    взаимодействие с внешними системами, либо это взаимодействие относительно быстрое
    (например, запрос в бд по индексу).
        
    * Расчет задания -- медленная операция, так как аналитические запросы выполняются на больших массивах
    данных. Это гораздо медленнее, чем делать запрос в базе по индексу (возможная операция в первой задаче) или 
    обработка в памяти.
        
    * Отправка результата задания по указанному адресу -- средняя по скорости операция. 
    Отправка POST запроса на внешний сервис
    происходит быстро, но здесь необходимо предусмотреть недоступность внешнего сервиса и связанные с этим сценарии. 
    
    В итоге получаем 3 функциональных модуля, каждый из которых выполняет свою независимую задачу с разной скоростью
    обработки.
    
    ??? tip "Совет" 
        Когда стоит выделять модуль в отдельный сервис?
        
        * имеет строго выделенную, независимую от других модулей зону ответственности. 
        
        * для выполнения функционала сервису необходимы только входные данные и сторонние системы: базы данных, брокеры
        сообщений, веб-сервисы.
        
        * есть требования к масштабируемости
    
        ??? "Термин"      
            Масштабируемость -- процесс, когда производительность системы пропорционально зависит от количества
            затраченных ресурсов. В бытовом плане чаще всего подразумевается горизонтальная машстабируемость, где
            под ресурсами имеется виду количество экземпляров сервиса            
    
    
    Представим, что нагрузка 
    на нашу систему стала резко расти. Первый модуль работает отлично. Но второй, рассчитывающий поступающие задания,
    не успевает обрабатывать возврастающий поток заданий и начинает захлебываться под нагрузкой. В итоге, задания
    не обрабатываются и производительность системы резко падает, так как второй модуль становится бутылочным горлышком. 
    
    Это происходит по причине неравномерной скорости работы модулей. Если скорость обработки у модулей отличаются
    на некоторую малую величину (давайте примем ее в 1 секунду. При условии, что скорость обработки в памяти занимает
    миллисекунды, то это довольно большая величина). 
    
    Для решения этой проблемы мы можем воспользоваться приемом [Замена прямых зависимостей на обмен сообщениями](archicture.md#_10).
    
    ??? example "Пример"
        Вы пришли в дикси за хлебом. Но на данный момент открыты только две кассы, а покупателей, желающих оплатить покупки
        и уйти, гораздо больше и их количество увеличивается. То есть нагрузка на кассы превышает их производительность.
        Для оплаты хлебушка, вы встаете в **очередь**
    
    
    Обмен сообщениями между модулями с разной скоростью работы мы организуем с помощью очередей. Одна очередь свяжет
    модули приема и расчета заданий, другая - модуль расчета и обработки результат заданий. 

Каждую такую задачу мы выделяем в отдельный модуль. В итоге, мы получаем следующие функциональные модули:

* Модуль приема заданий

* Модуль расчета заданий

* Модуль обработки результат

* И внешние системы:
    
    * Хранилище данных
        
??? "Пока рано"
    Очереди сообщений идут отдельной системой, так как они должны быть отказоустойчивыми и персистентными (чтобы в случае
    аварий не терять сообщения). 
    
    Определим стэк технологий для сторонних систем:
    
    * Брокер очередей. **RabbitMQ**. Популярный вариант для нагрузки ниже 10.000 сообщений/секунду. 
    * База данных для хранения заданий. **PostgreSQL/MySQL**. Два популярных варианта СУБД (системы управления базами данных)
    , если не требуется выполнять кучу 
    аналитических запросов. **PostgreSQL** сделан покачественней, имеет чуть больше возможностей и лучше документацию, но
    администрирование это просто кошмар. **MySQL** более дружелюбный, но функционал чуть ниже. По производительности 
    примерно одинаковы для простых запросов. Лучше выбирать тот вариант, который уже используется в компании.
    * База данных для аналитических запросов -- определяется тем, что уже есть. Так как обычно либо это **MS SQL/Oracle**,
    либо ClickHouse, либо Big Data (hadoop + spark/hive). Будем для простоты считать, что это jdbc совместимое хранилище, 
    поддерживающее стандарт SQL'92.         

Теперь рассмотрим каждый модуль в отдельности.

### Модуль приема заданий

Вспомним требования:

> Система принимает на вход задание, в которой описано, что необходимо посчитать, за какой период и URL на 
который необходимо отправить результат расчета

> Задания должны быть привязаны к пользователю, которые их отправил, и храниться в каком-либо хранилище

Попробуем проанализировать данное требование и подумать, что из него вытекает:

1. Для приема заданий нам необходимо REST API.
2. Раз есть пользователи, необходима авторизация
3. Для хранения заданий необходима база данных
4. Для отправки заданий на расчет необходим доступ к очередям

Теперь продумаем алгоритм работы нашего сервиса (опять функциональная декомпозиция + порядок действий):

1. Авторизовать пользователя
2. Провалидировать задание
    * Если задание невалидно, выдать ошибку.
    * Если задание валидно, переходим на следующий этап.    
3. Сохранить задание в базу данных
4. Предусмотреть пре-обработку задания. Да, в требованиях этого нет, но скорее всего это потребуется, и надо заложить
возможность для этого. 
5. Отправить задание в очередь.

Механизмы авторизации и валидации возложим на фреймворки (Spring Security, Spring MVC соответственно).

Остается подумать над шагами с 3 по 5. 

??? tip "Совет* Тоже пока рано"
    Все шаги алгоритма можно разделить на две группы: 
    
    * Промежуточный
     
    * Терминальный
    
    Промежуточный шаг -- это шаг, чей результат используется дальше по алгоритму, терминальный же наоборот.
     
    Например, шаг валидации. Результат этого шага будет влиять на все остальные этапы работы системы. Это промежуточный
    шаг. 
    
    Шаг сохранения задания в базу с первого взгляда кажется терминальным, так как сохраненная задача нигде
    в этом алгоритме далее не используется. Но! надо принять во внимание такой результат как ошибка при сохранении. 
    Что делать, если база не ответчает? Давать обратную связь пользователю ("Произошла ошибка, попробуйте еще раз")?
    
    Если же факт возникновения ошибки выполнении не так важен, то шаг можно считать терминальным.
    
    ![a](img/arch_pr1.jpg) 
    
    Терминальные шаги можно выполнять параллельно с остальными шагами (в отдельном треде, в отдельном
    сервисе, вариантов много). Но только клиентский код, использующий интерфейс вашего терминального шага не должен 
    знать таких подробностей выполнения, т.е. Вызывающий код не должен сам запускать терминальный шаг в другом потоке.

Каждый шаг алгоритма сервиса должен быть выполнен в виде интерфейса. Давайте попробуем.

#### Сохранение задания в базу данных

Когда мы пишем интерфейсы для обозначения поведения системы, то можно пока не заморачиваться насчет структуры 
обрабатываемых данных. Так как алгоритм обработки данных будет отражен в реализации, а на данном этапе мы вычисляем
общие требования к программному модулю. 

```java
import org.springframework.lang.NonNull; // (1)
/**
    Интерфейс модуля сохранения задания в хранилище
 */
public interface TaskSaver {
    
    /**
        Сохраняет задание
        
        @param task - задание (2)
        @return     - сохраненное задание (3)
        @throws NullPointerException - в случае если task равно {@literal null}
        @throws TaskSaveException - при ошибке сохранения (4) 
     */
    @NonNull // (5)
    Task save(@NonNull /* (6) */ Task task) throws TaskSaveException; // (7)
}
``` 

Пошаговый гайд о разработке интерфейсов можно посмотреть [тут](interface.md) 
    
##### Пре-обработка задания

В требованиях у нас не стоит необходимость в обработке заданий. 
Но само наличие такой обработки мы должны предусмотреть, так сказать, предугадать вектор изменений приложения.

> Для многих это будет весьма спорным моментом, но я всегда стараюсь думать наперед и меня это не подводило. 
Благодаря опциональным зависимостям, можно даже реализацию для этого интерфейса не писать, но самое его наличие
может здорово нам помочь, не переписывая старый код.


Более того, мы можем иметь много таких обработчиков, поэтому было бы здорово создавать из них цепочки:

```java
/**
 * Обработчик задания. Можно выстраивать в цепочки.
 */
public interface TaskPreHandler {

    /**
     * Реализация по умолчанию
     */
    TaskPreHandler DUMMY = task -> task;

    /**
     * Строит цепочку из коллекции обработчиков
     * @param handlers обработчики
     * @param comparator компоратор, определяющий порядок выполнения в цепочки
     * @return композитный обработчик,
     */
    static TaskPreHandler createChain(Collection<TaskPreHandler> handlers, Comparator<TaskPreHandler> comparator) {
        if (handlers == null) {
            return DUMMY;
        }
        return handlers.stream().sorted(comparator).reduce(TaskPreHandler::andThen).orElse(DUMMY);
    }


    /**
     * Обрабатывает задание перед отправкой на расчет
     *
     * @param task задание
     * @return задание после обработки. Если обработка неприменима, то возвращается исходное задание
     * @throws TaskHandlerException ошибка обработки
     */
    Task apply(Task task) throws TaskHandlerException;


    /**
     * Метод для построения цепочек. Выполянет сначала собственную обработку, затем обработчик из аргумента
     *
     * @param other следующий обработчик
     * @return композитный обработчик
     */
    default TaskPreHandler andThen(TaskPreHandler other) {
        return task -> other.apply(apply(task));
    }
}
```

Это общий паттерн для ситуаций, когда у нас есть 0...N обработчиков (или фильтров), которые могут возникать и появляться. 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    