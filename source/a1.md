# Архитектура на практике

## Введение

Перед прочтением данной главы, ознакомьтесь с [главой про архитектуру](archicture.md), а также c
[Пошаговым гайдом о разработке интерфейсов](interface.md).

Здесь же мы разберем на практике принципы и приемы по построению грамотного дизайна на примере нескольких систем.

Так как данная книга по спрингу, то и реализации у нас тоже будут на спринге. Но мы постараемся также рассмотреть 
и аналоги (но не Java EE, от которой отказались даже родители)

Рассмотрим такую систему:

Система для расчета некоторых показателей по имеющимся данным в 
аналитических целях.   

Требования: 

* Система принимает на вход задание через Web API, 
в которой описано, что необходимо посчитать, за какой период и URL, на 
который необходимо отправить результат расчета

* Задания должны быть привязаны к пользователю, которые их отправил, 
и храниться в каком-либо хранилище

* После расчета на указанный в задаче URL должен быть отправлен результат задания

* Должна быть поддержка нескольких типов заданий

## Трехслойная архитектура

Большинство приложений (модулей) строятся по трехслойной архитектуре:

![3layer](img/arch_pr2.png)

Иногда ее называют тортик-архитектура. Принципы:

* Приложение делится на 3 слоя
* Каждый слой должен зависеть только от слоя на один уровень ниже (но только строго на один уровень ниже, т.е. 
**Presentation Layer** (servlet) зависит от **Business Layer**, но ничего знает про **Data Access Layer** (repository)).
* Каждый слой ничего не должен знать про слои выше.

Виды слоев: 

* **Presentation Layer** -- слой для взаимодействия с пользователем. Данный слой ответственнен прием и отдачу данных,
их преобразование в термины вашей системы. Например, пользователь присылает вам запрос с json-сообщением, а слой 
представления должен преобразовать этот запрос в объект `Task`. И наоборот, данный слой конвертирует сущности вашей
системы в формат, удобный для пользователя (тот же самый json, html страничка и так далее.). 

    ???+ danger "Важно"
        Слой представления не должен содержать в себе логики. Он отвечает только за конвертацию входных данных в термины
        вашей системы и наоборот. Любая логика запрещена. Это правило следует из принципа Единой ответственности.

* **Business Layer** -- слой бизнес-логики. Самый главный слой вашей системы. Инкапсулирует логику работы приложения. 

* **Data Access Layer** -- слой взаимодействия с хранилищем данных. Хранилищем данных может выступать не только СУБД,
но и веб-сервисы, файлы. В этом слое реализованы атомарными операции с данными (CRUD). Если на Data Access Layer вам
хочется сделать в одном методе несколько вызовов к бд, это означает, что вашему коду место на слой выше. 

При проектировании информационной системы на первом этапе сосредоточится на слое бизнес-логике (Business Layer).
    
## Декомпозиция

Первым шагом при решении любой задачи является декомпозиция: разбиение большой задачи на задачи поменьше. 

Начнем с [иерархической декомпозиции](archicture.md#_5).

Наша система должен считать задания и отправлять результаты на URL, указанный в задании. Давайте порисуем в блокнотике:

![calc](img/arch_pr3.png)

Так как мы принимаем запрос по http, а этот протокол подразумевает получение ответа на каждый запрос, 
то нам пользователю необходимо отдать какой-либо ответ, например, задача принята на расчет или произошла ошибка.
Поэтому немного модернизируем нашу схему:

![calc1](img/arch_pr4.png)

 
Далее разобьем большой модуль *Calculator* на несколько модулей (задач) поменьше.  

Для этого применим [функциональную декомпозицию](archicture.md#_6). 

Давайте определим независисые друг от друга задачи, которые должна выполнять система, исходя из требований:

* Система должна хранить задания с привязкой к пользователю. 

* Система должна рассчитывать задания

* Система должна отправлять результат задания на внешний сервис

Каждой задаче будет соответствовать свой модуль. Нарисуем новую схему: 

![calc2](img/arch_pr5.png)

Каждую такую задачу мы выделяем в отдельный модуль. В итоге, мы получаем следующие функциональные модули:

* Модуль пред-обработки заданий (сохранение) (**Task Pre-Handler**)

* Модуль расчета заданий (**TaskCalculator**)

* Модуль обработки результата задания (**ResultHandler**)

А вот дальше уже проблема. Если три модуля выше были очевидны из требований, то как разбивать дальше уже плохо 
понятно. В таком случае, что мы говорим дальнейшей декомпозиции? Не сегодня. И переходим к практике. 

???+ tip "Совет"
    Если при декомпозиции вы не можете разбить задачу на более мелкие, оставьте ее единым целом. При написании 
    реализации появится ясность, как разбивать дальше.

Каждому модулю должен соответствовать интерфейс с описание входных и возвращаемых данных, ограничений, описания 
возвращаемых значений, исключений и так далее. 

Модуль *Calculator* состоит из нескольких модулей поменьше. Вопрос в том, делать ли для него интерфейс? Да, так как
это полноценный модуль, с входными-выходными данными. Это и есть паттерн [Фасад](archicture.md#_8).  

Приступим к написанию интерфейса. Для этого вспомним нашу схему:

![calc1](img/arch_pr4.png)

Как видно из схемы, мы принимаем Task, возвращаем Feedback. Связь с внешним сервисом у нас будет инкапсулирована
внутри нашего модуль *Calculator*. Немного кода:

```java
import org.springframework.lang.NonNull;

/**
* Калькулятор заданий в целом. Принимает задание на расчет 
* и отдает обратную связь (сообщение)
*/
public interface TaskCalculatorFacade {
    
    @NonNull Feedback calculate(@NonNull Task task);
}
```

Это будет главный интерфейс для доступа к нашей системе (не забываем, что это называется [Фасад](archicture.md#_8)). 

Теперь опустимся на уровень ниже и напишем интерфейсы для модулей поменьше, согласно нашей схеме:

![calc2](img/arch_pr5.png)
 

Получаем:

```java
import org.springframework.lang.NonNull;

/**
* Модуль пред-обработки заданий (сохранение)
* 
*/
public interface TaskPreHandler {
    
    /**
    * Обработывает задание. Способ обработки зависит от реализации. 
    * 
    * {@link Task} - модель представления задания   
    * 
    * @param task задание. 
    * @return контейнер для задания. Необходим, если вместо с задачей 
    * надо передать дополнительную информацию
    * @throws TaskHandleException ошибка при обработке
    */
    @NonNull
    Task handle(@NonNull Task task) throws TaskHandleException; 
}
```

```java
import org.springframework.lang.NonNull;

/**
* Модуль расчета заданий
*/
public interface TaskCalculator {
    
    /**
    * Расчитывает задание
    * @param task задание
    * @return результат задания
    * @throws CalculateException ошибка при расчете задания
    */
    @NonNull
    Result calculate(@NonNull Task task) throws CalculateException; 
}
```      
    
```java
import org.springframework.lang.NonNull;

/**
* Модуль обработки результата задания
*/
public interface ResultHandler {
    
    /**
    * Обрабатывает результат расчета задания
    * @param result результат расчета
    * @return сообщение об успешной обработки результата
    * @throws ResultHandleException ошибка при обработке результата
    */
    ResultInfo handle(@NonNull Result result) throws ResultHandleException;
    
}
```    
    
???+ danger "Важно"
    При проектировании системы, как может заметить внимательный читатель, мы не обращали внимание
    на структуру обрабатываемых данных. В интерфейсах выше пока стоят модели (Data Transfer Object или DTO) без какой-либо
    структуры, так как структура данных не играет роли. Структура данных влиет прежде всего на реализации. 
   
Теперь мы можем написать реализацию для нашего калькулятора-фасада:

```java
public class TaskCalculatorFacadeImpl implements TaskCalculatorFacade {

    private final TaskPreHandler taskPreHandler;

    private final TaskCalculator taskCalculator;

    private final ResultHandler resultHandler;

    public TaskCalculatorFacadeImpl(
            TaskPreHandler taskPreHandler,
            TaskCalculator taskCalculator,
            ResultHandler resultHandler
    ) {
        this.taskPreHandler = taskPreHandler;
        this.taskCalculator = taskCalculator;
        this.resultHandler = resultHandler;
    }


    public Feedback calculate(Task task) {
        try {

            Task handledTask = taskPreHandler.handle(task);
            Result result = taskCalculator.calculate(handledTask);
            ResultInfo resultInfo = resultHandler.handle(result);
            return Feedback.fromResult(resultInfo);
        } catch (CalculateException | TaskHandleException | ResultHandleException e) {
            return Feedback.fromThrowable(e);
        }
    }
}
```

Остается написать реализацию для оставшихся интерфейсов.
 
Прикручиваем **Presentation Layer** :

```java
@Controller
@RequestMapping("/task")
public class TaskController {
    
    private final TaskCalculatorFacade calculator;
    
    public TaskController(TaskCalculatorFacade calculator) {
        this.calculator = Objects.requireNonNull(calculator);
    }
    
    // Spring MVC сам преобразует json сообщение в DTO и обратно
    @PostMapping
    public ResponseEntity<Feedback> sendTask(@RequestBody Task task) {
        Feedback feedback = calculator.calculate(task);
        // по хорошему для разных фидбэков нужен разный стастус, 
        // но для простоты пока пусть будет так
        return ResponseEntity.ok(feedback); 
    }
}
```  

И напишем пример использования **Data Access Layer** в реализации `TaskPreHandler`:

```java
@Component
public class TaskSaver implements TaskPreHandler {
    
    private final TaskRepository taskRepository;
    
    public TaskSaver(TaskRepository taskRepository) {
        this.taskRepository = Objects.requireNonNull(taskRepository);
    }
    
    @NonNull
    public Task handle(@NonNull Task task) throws TaskHandleException {
        try {
            return taskRepository.save(task);
        } catch (PersistenceException ex) {
            throw new TaskHandleException(ex);
        }
    }
}
```

Все примеры кода можно будет посмотреть в проекте на [github](https://github.com/eutkin/archicture). 

## Расширение функционала через композитные бины

Через какое-то время     
    
## Требования или немного лирики
 
Требования -- это головная боль разработчика. Почему? Потому что явление, когда кто-то может внятно и подробно объяснить,
что он, собственно, от вас хочет, довольно редкое. 

Как в теории:

* Аналитик (или менеджер) работает с клиентом и выясняет, чего хочется клиенту. Как он это делает? Не наша головная боль,
а его. 

* Аналитик (или менеджер) передает собранные требования системному аналитику, который переводит их с языка гуманитариев
на язык инженеров. Он формализует все требования и по итогу мы получаем некий документ (user story) с их подробным 
описанием.

* Тимлид разбивает требования на задачи и раскидывает по разрабам, в итоге у разраба есть четкие требования, что 
от него требуется сделать. 

Как в жизни:

* "Нам надо расчитать такие-то характеристики, как их рассчитать спроси у Марины, и сделай еще, чтобы результат
на почту приходил, и да, надо сделать какое-нибудь REST API еще. И давай быстрее, нам вчера надо"

 И ты 3 дня ходишь выясняешь, а что все-таки требуется и в каком виде, а в итоге выясняется, что Марина в отпуске и
 больше никто про эти характеристики не знает, что хотели совсем другое и вообще это понадобится через полгода.
 
Что с этим делать? Либо требовать, чтобы формулировали хотя бы самые основные требования, либо увольняться, потому что
по итогу все равно ты останешься виноватым (либо валить все на тимлида).

Ладно, ближе к делу.    

Требования бывают явные и неявные. С явными все понятно -- "Если пользователь делает действие А, то должно происходить
действие Б и В". То есть они явно где-то заданы: в тикете, в user story, в документации. 

С неявными сложнее. Неявные требования -- это хотелки, которые подразумевается. Например, нигде где явно не написано, 
что пользователю надо отдавать описание ошибки, если таковая произошла. Но она подразумевается. 

Принцип работы с неявными требованиями заключается, что некоторые вещи довольно стандартны и можно взять на вооружение
алгоритмы из имеющихся сервисов, та же обработка ошибок. Либо говорить, что этого не было в требованиях, поэтому этого 
и нет. Но здесь, как и везде, очень важно соблюдать баланс между здравым смыслом и идиотией.  

Пример неявных требований из тз, приведенного в начале статьи: необходимо описать формат входных-выходных данных, так 
как в требованиях это не прописано. Или что делать, если задача не может быть рассчитана?

В случае с неявными требованиями очень важно вести какую-нибудь документацию по проекту, потому что с большой долей
вероятностью она вам понадобится. Если вы приняли какое-то решение по неявному требованию (делаем вот так), то желательно
согласовать его с заказчиком, вежливо, но жестко. Формальное согласие потом здорово вам поможет после разработки и снимет
с вам любую ответственность. 

Теперь перейдем непосредственно к проектированию    