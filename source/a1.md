# Архитектура на практике

## Введение

Перед прочтением данной главы, ознакомьтесь с [главой про архитектуру](archicture.md), а также c
[Пошаговым гайдом о разработке интерфейсов](interface.md).

Здесь же мы разберем на практике принципы и приемы по построению грамотного дизайна на примере нескольких систем.

Так как данная книга по спрингу, то и реализации у нас тоже будут на спринге. Но мы постараемся также рассмотреть 
и аналоги (но не Java EE, от которой отказались даже родители)

Рассмотрим такую задачу:

Есть большой объем данных по продажам мобильных устройств в Китае, который хранится  в колоночкой базе данных 
с поддержкой SQL`92. Нашим клиентам хотелось бы получать различные статистики по продажам, например, количество
проданных телефонов определенной марки (например, Huawei) или отношение проданных телефонов с вырезом на экране 
к телефонам без выреза в %. 

Требования: 

* Система принимает на вход задание через Web API, 
в которой описано, что необходимо посчитать, за какой период и URL, на 
который необходимо отправить результат расчета

* Задания должны быть привязаны к пользователю, которые их отправил, 
и храниться в каком-либо хранилище

* После расчета на указанный в задаче URL должен быть отправлен результат задания

* Должна быть поддержка нескольких типов заданий

## Трехслойная архитектура

Большинство приложений (модулей) строятся по трехслойной архитектуре:

![3layer](img/arch_pr2.png)

Иногда ее называют тортик-архитектура. Принципы:

* Приложение делится на 3 слоя
* Каждый слой должен зависеть только от слоя на один уровень ниже (но только строго на один уровень ниже, т.е. 
**Presentation Layer** (servlet) зависит от **Business Layer**, но ничего знает про **Data Access Layer** (repository)).
* Каждый слой ничего не должен знать про слои выше.

Виды слоев: 

* **Presentation Layer** -- слой для взаимодействия с пользователем. Данный слой ответственнен прием и отдачу данных,
их преобразование в термины вашей системы. Например, пользователь присылает вам запрос с json-сообщением, а слой 
представления должен преобразовать этот запрос в объект `Task`. И наоборот, данный слой конвертирует сущности вашей
системы в формат, удобный для пользователя (тот же самый json, html страничка и так далее.). 

    ???+ danger "Важно"
        Слой представления не должен содержать в себе логики. Он отвечает только за конвертацию входных данных в термины
        вашей системы и наоборот. Любая логика запрещена. Это правило следует из принципа Единой ответственности.

* **Business Layer** -- слой бизнес-логики. Самый главный слой вашей системы. Инкапсулирует логику работы приложения. 

* **Data Access Layer** -- слой взаимодействия с хранилищем данных. Хранилищем данных может выступать не только СУБД,
но и веб-сервисы, файлы. В этом слое реализованы атомарными операции с данными (CRUD). Если на Data Access Layer вам
хочется сделать в одном методе несколько вызовов к бд, это означает, что вашему коду место на слой выше. 

При проектировании информационной системы на первом этапе сосредоточится на слое бизнес-логике (Business Layer).
    
## Декомпозиция

Первым шагом при решении любой задачи является декомпозиция: разбиение большой задачи на задачи поменьше. 

Начнем с [иерархической декомпозиции](archicture.md#_5).

Наша система должен считать задания и отправлять результаты на URL, указанный в задании. Давайте порисуем в блокнотике:

![calc](img/arch_pr3.png)

Так как мы принимаем запрос по http, а этот протокол подразумевает получение ответа на каждый запрос, 
то нам пользователю необходимо отдать какой-либо ответ, например, задача принята на расчет или произошла ошибка.
Поэтому немного модернизируем нашу схему:

![calc1](img/arch_pr4.png)

 
Далее разобьем большой модуль *Calculator* на несколько модулей (задач) поменьше.  

Для этого применим [функциональную декомпозицию](archicture.md#_6). 

Давайте определим независисые друг от друга задачи, которые должна выполнять система, исходя из требований:

* Система должна хранить задания с привязкой к пользователю. 

* Система должна рассчитывать задания

* Система должна отправлять результат задания на внешний сервис

Каждой задаче будет соответствовать свой модуль. Нарисуем новую схему: 

![calc2](img/arch_pr5.png)

Каждую такую задачу мы выделяем в отдельный модуль. В итоге, мы получаем следующие функциональные модули:

* Модуль пред-обработки заданий (сохранение) (**Task Pre-Handler**)

* Модуль расчета заданий (**TaskCalculator**)

* Модуль обработки результата задания (**ResultHandler**)

А вот дальше уже проблема. Если три модуля выше были очевидны из требований, то как разбивать дальше уже плохо 
понятно. В таком случае, что мы говорим дальнейшей декомпозиции? Не сегодня. И переходим к практике. 

???+ tip "Совет"
    Если при декомпозиции вы не можете разбить задачу на более мелкие, оставьте ее единым целом. При написании 
    реализации появится ясность, как разбивать дальше.

Каждому модулю должен соответствовать интерфейс с описание входных и возвращаемых данных, ограничений, описания 
возвращаемых значений, исключений и так далее. 

Модуль *Calculator* состоит из нескольких модулей поменьше. Вопрос в том, делать ли для него интерфейс? Да, так как
это полноценный модуль, с входными-выходными данными. Это и есть паттерн [Фасад](archicture.md#_8).  

Приступим к написанию интерфейса. Для этого вспомним нашу схему:

![calc1](img/arch_pr4.png)

Как видно из схемы, мы принимаем Task, возвращаем Feedback. Связь с внешним сервисом у нас будет инкапсулирована
внутри нашего модуль *Calculator*. Немного кода:

```java
import org.springframework.lang.NonNull;

/**
* Калькулятор заданий в целом. Принимает задание на расчет 
* и отдает обратную связь (сообщение)
*/
public interface TaskCalculatorFacade {
    
    @NonNull Feedback calculate(@NonNull Task task);
}
```

Это будет главный интерфейс для доступа к нашей системе (не забываем, что это называется [Фасад](archicture.md#_8)). 

Теперь опустимся на уровень ниже и напишем интерфейсы для модулей поменьше, согласно нашей схеме:

![calc2](img/arch_pr5.png)
 

Получаем:

```java
import org.springframework.lang.NonNull;

/**
* Модуль пред-обработки заданий (сохранение)
* 
*/
@FunctionalInterface // контроллирует, что интерфейс имеет только один недефолтный метод. 
// Это небходимо, чтобы мы могли писать реализации интерфейсы в виде лямбды 
public interface TaskPreHandler {
    
    /**
    * Обработывает задание. Способ обработки зависит от реализации. 
    * 
    * {@link Task} - модель представления задания   
    * 
    * @param task задание. 
    * @return контейнер для задания. Необходим, если вместо с задачей 
    * надо передать дополнительную информацию
    * @throws TaskHandleException ошибка при обработке
    */
    @NonNull
    Task handle(@NonNull Task task) throws TaskHandleException; 
}
```

```java
import org.springframework.lang.NonNull;

/**
* Модуль расчета заданий
*/
@FunctionalInterface 
public interface TaskCalculator {
    
    /**
    * Расчитывает задание
    * @param task задание
    * @return результат задания
    * @throws CalculateException ошибка при расчете задания
    */
    @NonNull
    Result calculate(@NonNull Task task) throws CalculateException; 
}
```      
    
```java
import org.springframework.lang.NonNull;

/**
* Модуль обработки результата задания
*/
@FunctionalInterface 
public interface ResultHandler {
    
    /**
    * Обрабатывает результат расчета задания
    * @param result результат расчета
    * @return сообщение об успешной обработки результата
    * @throws ResultHandleException ошибка при обработке результата
    */
    ResultInfo handle(@NonNull Result result) throws ResultHandleException;
    
}
```    
    
???+ danger "Важно"
    При проектировании системы, как может заметить внимательный читатель, мы не обращали внимание
    на структуру обрабатываемых данных. В интерфейсах выше пока стоят модели (Data Transfer Object или DTO) без какой-либо
    структуры, так как структура данных не играет роли. Структура данных влиет прежде всего на реализации. 
    
Напишем для примера реализацию `TaskPreHandler` с использованием **Data Access Layer**:

```java
@Service
public class TaskSaver implements TaskPreHandler {
    
    // это интерфейс из Data Access Layer
    private final TaskRepository taskRepository;
    
    public TaskSaver(TaskRepository taskRepository) {
        this.taskRepository = Objects.requireNonNull(taskRepository);
    }
    
    @NonNull
    public Task handle(@NonNull Task task) throws TaskHandleException {
        try {
            return taskRepository.save(task);
        } catch (PersistenceException ex) {
            throw new TaskHandleException(ex);
        }
    }
}
```    
   
После декомпозиции большого модуля, мы можем написать реализацию для его интерфейса. которая объединит через композицию
модули поменьше:

```java
public class TaskCalculatorFacadeImpl implements TaskCalculatorFacade {

    private final TaskPreHandler taskPreHandler;

    private final TaskCalculator taskCalculator;

    private final ResultHandler resultHandler;

    public TaskCalculatorFacadeImpl(
            TaskPreHandler taskPreHandler,
            TaskCalculator taskCalculator,
            ResultHandler resultHandler
    ) {
        this.taskPreHandler = Objects.requireNonNull(taskPreHandler);
        this.taskCalculator = Objects.requireNonNull(taskCalculator);
        this.resultHandler =  Objects.requireNonNull(resultHandler);
    }

    public Feedback calculate(Task task) {
        try {

            Task handledTask = taskPreHandler.handle(task);
            Result result = taskCalculator.calculate(handledTask);
            ResultInfo resultInfo = resultHandler.handle(result);
            return Feedback.fromResult(resultInfo);
        } catch (CalculateException | TaskHandleException | ResultHandleException e) {
            return Feedback.fromThrowable(e);
        }
    }
}
```

Далее пишем реализации для оставшихся интерфейсов. 
 
В качестве примера дальнейшей декомпозиции возьмем `TaskCalculator`. И идем известным путем. У нас есть большая 
задача (расчет заданий), которую надо разбить на несколько маленьких. Начинаем снова рассуждать. 

Данные по продажам лежат в базе с поддержкой SQL. Значит получать выборку для расчета или уже готовые значения
мы можем через SQL. 

Попытаемся разобраться, что нам будет необходимо для реализации калькулятора:

* SQL Query Generator. Модуль, который будет генерировать sql запрос на основе задания (`Task`)
* SQL Executor. Модуль, который будет выполнять sql запрос и возвращать нам какие-то данные (либо выборку, либо 
рассчитанные значения).   
* SQL ResultSet Handler. Модуль обработки результа запроса

Продолжаем рисовать и дополняем нашу схему:

![calc6](img/arch_pr6.png)

Набросаем интерфейсы:

```java
/**
* Модуль, который будет генерировать sql запрос на основе задания (`Task`)
*/
@FunctionalInterface
public interface SqlQueryGenerator {
    
    /**
    * Генерирует sql запрос для задания
    * @param task задание
    * @return sql запрос
    * @throws QueryGenerateException если для задания невозможно сгенерировать валидный sql запрос
    */
    @NonNull
    String generate(@NonNull Task task) throws QueryGenerateException;
} 
```

Для простоты интерфейсы остальных модулей опустим.

Пишем реализацию для `TaskCalculator`:

```java
public class SqlTaskCalculator implements TaskCalculator {
    
    private final SqlQueryGenerator sqlQueryGenerator;
    private final SqlExecutor sqlExecutor;
    private final SqlResultSetHandler resultSetHandler;
    
    public SqlTaskCalculator(
                SqlQueryGenerator sqlQueryGenerator,
                SqlExecutor sqlExecutor,
                SqlResultSetHandler resultSetHandler
    ) {
        this.sqlQueryGenerator = Objects.requireNonNull(sqlQueryGenerator);
        this.sqlExecutor = Objects.requireNonNull(sqlExecutor);
        this.resultSetHandler = Objects.requireNonNull(resultSetHandler);
    }
    
    @NonNull
    public Result calculate(@NonNull Task task) throws CalculateException {
        try {
            String sql = sqlQueryGenerator.generate(task);
            SqlResultSet resultSet = sqlExecutor.execute(sql);
            Result result = resultSetHandler.handle(resultSet);
        } catch (QueryGenerateException /* | Исключения других интерфейсов */ ex) {
            throw new CalculateExecption(ex);
        }
    } 
}
```

И так шаг за шагом доводим систему до готовности.

После того, как мы закончили со слоем бизнес-логики, то прикручиваем остальные слои:

**Presentation Layer** :

```java
@Controller
@RequestMapping("/task")
public class TaskController {
    
    private final TaskCalculatorFacade calculator;
    
    public TaskController(TaskCalculatorFacade calculator) {
        this.calculator = Objects.requireNonNull(calculator);
    }
    
    // Spring MVC сам преобразует json сообщение в DTO и обратно
    @PostMapping
    public ResponseEntity<Feedback> sendTask(@RequestBody Task task) {
        Feedback feedback = calculator.calculate(task);
        // по хорошему для разных фидбэков нужен разный стастус, 
        // но для простоты пока пусть будет так
        return ResponseEntity.ok(feedback); 
    }
}
```  

## Расширение функционала через композитные бины

Для мониторинга калькулятора неплохо было бы добавить метрику, которая учитывала бы количество поступивших заданий. 
Возникает вопрос, как добавить такой функционал в существующую систему. Как мы помним, нам нельзя менять существующий
код (прицип **Open-Close** или принцип **Открытости-Закрытости**). Поэтому воспользуемся таким паттерном как 
[Chain of Responsibility](https://refactoring.guru/ru/design-patterns/chain-of-responsibility). Он же композитный бин,
так как внутри состоит из нескольких бинов.

```java
@Configuration
public class SomeConfiguration {
    
   @Bean
   @Primary // это аннотация означает, что если есть несколько бинов, реализаций одного интерфейса, 
   // то при использовании @Autowired будет внедрен бин, помечененный аннотацией @Primary.
   public TaskPreHandler compositeTaskPreHandler(
           @Autowired(required = false) List<TaskPreHandler> handlers
   ) {
       Stream<TaskPreHandler> handlerStream = handlers == null ? 
                       Stream.empty() : handlers.stream();
       BinaryOperator<TaskPreHandler> operator = (handler, nextHandler) -> 
               task -> nextHandler.handle(handler.handle(task));
       // сложный кусок. Здесь мы все обработчики объединяем в 
       // одну длинную последовательную цепочку.      
       this.delegate = handlerStream
               .reduce(task -> task, operator);
   }
}
```

Теперь для добавления нового обработчика для мониторинга, мы просто создаем еще один бин:

```java
@Component
public class MonitoringTaskCounter implements TaskPreHandler {
    
    private final CounterService counterService;
    
    public MonitoringTaskCounter(CounterService counterService) {
        this.counterService = Objects.requireNonNull(counterService);
    }
    
    @NonNull
    public Task handle(@NonNull Task task) throws TaskHandleException {
        counterService.increment("counter.task.input");
        return task;
    }
}
```

В итоге, сначала будет выполнен TaskSaver, а затем MonitoringTaskCounter. Или наоборот, так как порядок мы не задали.
Порядок выполнения можно задать через аннотацию @Order/интерфейс PriorityOrdered | Ordered. 

Тоже самое можно применить и для `ResultHandler`, если нам понадобится больше обработок. 

    
## Требования или немного лирики
 
Требования -- это головная боль разработчика. Почему? Потому что явление, когда кто-то может внятно и подробно объяснить,
что он, собственно, от вас хочет, довольно редкое. 

Как в теории:

* Аналитик (или менеджер) работает с клиентом и выясняет, чего хочется клиенту. Как он это делает? Не наша головная боль,
а его. 

* Аналитик (или менеджер) передает собранные требования системному аналитику, который переводит их с языка гуманитариев
на язык инженеров. Он формализует все требования и по итогу мы получаем некий документ (user story) с их подробным 
описанием.

* Тимлид разбивает требования на задачи и раскидывает по разрабам, в итоге у разраба есть четкие требования, что 
от него требуется сделать. 

Как в жизни:

* "Нам надо расчитать такие-то характеристики, как их рассчитать спроси у Марины, и сделай еще, чтобы результат
на почту приходил, и да, надо сделать какое-нибудь REST API еще. И давай быстрее, нам вчера надо"

 И ты 3 дня ходишь выясняешь, а что все-таки требуется и в каком виде, а в итоге выясняется, что Марина в отпуске и
 больше никто про эти характеристики не знает, что хотели совсем другое и вообще это понадобится через полгода.
 
Что с этим делать? Либо требовать, чтобы формулировали хотя бы самые основные требования, либо увольняться, потому что
по итогу все равно ты останешься виноватым (либо валить все на тимлида).

Ладно, ближе к делу.    

Требования бывают явные и неявные. С явными все понятно -- "Если пользователь делает действие А, то должно происходить
действие Б и В". То есть они явно где-то заданы: в тикете, в user story, в документации. 

С неявными сложнее. Неявные требования -- это хотелки, которые подразумевается. Например, нигде где явно не написано, 
что пользователю надо отдавать описание ошибки, если таковая произошла. Но она подразумевается. 

Принцип работы с неявными требованиями заключается, что некоторые вещи довольно стандартны и можно взять на вооружение
алгоритмы из имеющихся сервисов, та же обработка ошибок. Либо говорить, что этого не было в требованиях, поэтому этого 
и нет. Но здесь, как и везде, очень важно соблюдать баланс между здравым смыслом и идиотией.  

Пример неявных требований из тз, приведенного в начале статьи: необходимо описать формат входных-выходных данных, так 
как в требованиях это не прописано. Или что делать, если задача не может быть рассчитана?

В случае с неявными требованиями очень важно вести какую-нибудь документацию по проекту, потому что с большой долей
вероятностью она вам понадобится. Если вы приняли какое-то решение по неявному требованию (делаем вот так), то желательно
согласовать его с заказчиком, вежливо, но жестко. Формальное согласие потом здорово вам поможет после разработки и снимет
с вам любую ответственность. 

Теперь перейдем непосредственно к проектированию    