# Современное ООП или почему классическое ООП мертво?

## Классическое ООП, которое мы все знаем

Как объясняют ООП в большинстве случаев? 

Есть класс `Animal`, от него наследуются `Cat` и `Dog`. Животное может иметь цвет, имя, издавать звуки и бегать.

```java
abstract class Animal {
    
   protected String name;
    
   protected Animal(String name) {
       this.name = name;
   }
    
   public abstract void run();
    
   public respondName(String anyName) {
       if (name.equals(anyName)) {
           run();
       }
   }
}

class Cat extends Animal {
    
    public Cat(String name) {
        super(name);
    }
    
    @Override
    public void run() {
       System.out.println("Дык дык дык");
    }
     
    public void climbTree() {
        // cat can to climb a tree
    }
}

class Dog extends Animal {
    
    public Cat(String name) {
        super(name);
    }
    
    @Override
    public void run() {
       System.out.println("*звук бегающей собаки*");
    }
    
    public void bringBall() {
        // dog can bring the ball
    }
}

public class Main {
    public static void main(String[] args){
      for (Animal animal : asList(new Cat("Barsik", RED), new Dog("GoodBoy", BLUE))) {
          animal.respondName("Barsik");        
      }
    }
}

// printed: Дык дык дык
```

Каждый класс представляет собой объект реального мира, у которого есть какие-то характеристики и поведение. 

В этом сниппете кода можно увидеть все принципы ООП:

* Наследование. Кошка и собака наследуют все черты, характерные для класса Животные, который мы описали. Они не 
только могут откликаться на свои имя и  бегать, но и имеют уникальные черты, например, кошка может забираться 
на дерево, а собака - приносить мячик.
* Инкапсуляция. Здесь инкапулирован поле с именем, его значение вне класса мы получить не можем.
* Полиморфизм. Не зависимо от типа животного, кошка или собака, мы можем окликнуть их по имени, так как это 
свойственно классу Животные.
* Абстракция. При создании классов мы взяли только свойства и поведение, которые нам необходимы, а не описывали
все детально. То есть, наш класс Животное - это некая абстракция над реальным животным, над объектом реального мира.

Не так сложно, да? Но что же могло пойти не так...

## Почему классическое ООП умерло?

### Маленький жизненный пример

Вы устроились на работу программистом Java и ваше первое большое и ответственное задание - написать с коллегой
REST сервис, который отдает информацию о офисных работниках фирмы. Информация о работниках лежит в текстовых файлах 
на файловом сервере компании. Ваш коллега написать REST часть (ок, гугл, что такое REST), ваша задачи прочитать
из файлов работников.

Так, погодите, а где кошечки и собачки? Эй? Хм, хорошо. у нас есть хотя бы класс Работник, да? Отлично, давайте
напишем для него класс.

```java
public class Employee {
    private Long id;
    private String name;
} 
```

Так, мы создали класс, добавили туда пару полей, заинкапсулировали их. Осталось добавить пару действий, которые
могут выполнять наши работники и все будет отлично. Хм. Так, мы же пишем REST сервис, а он обычно отдает информацию
в JSON (другие программисты говорили об этом в курилке). Добавим метод конвертации в json, как раз прям классика
будет:

```java
public class Employee {
    private Long id;
    private String name;
    
    public String toJson() {
        return "{\"id\": " + id + ", \"name\" : " + name + " }";
    }
} 
```

А что у нас говорит ООП? Классы моделируют объекты реального мира, а умеют ли у нас работник компании
преобразовывать себя в Json? Что-то сомнительно. Но это мелочи жизни, давайте пойдем дальше.

Работники у нас хранятся в файлах и нам их надо оттуда достать. Давайте подумаем, как это сделать в рамках
классического ООП.

Если мы добавили метод для преобразования данных в json, почему бы не добавить метод для чтения
работника из файла? Нет, это глупо, работник же не может сам себя вычитать из файла. Значит, это должен делать
кто-то другой. Но мы можем сделать конструктор для класс Работник, который принимает строку из файла и создать класс
Архив, который будет читать работников из файла:
```java
public class Employee {
    
    private Long id;
    private String name;
    
    public Employee(String line) {
        String[] parts = line.split(",");
        this.id = Long.parseLong(parts[0]);
        this.name = parts[1];
    }
    
    public String toJson() {
        return "{\"id\": " + id + ", \"name\" : " + name + " }";
    }
} 

public interface IArchive<T> {
    
     List<T> getObjects();
     
}

public abstract class Archive<T> {
    
    protected List<T> objects = new ArrayList<>();
    
    protected List<String> lines = new ArrayList<>();
    
    private final String fileName;
    
    protected Archive(String fileName) {
        this.fileName = fileName;
    }
    
    protected void readFromFiles() {
        // здесь реализовано неблокирующее чтение.
        // писать я его не буду, потому что это сложнее, чем привычное блокирующее чтение из файла
        // но неблокирующее выбрано, чтобы не создавать непреодолимых узких мест в системе,
        // так как мы дальше коснемся многопоточки и производительности
        this.lines = unlockableReadLines;
    }
    
    public List<T> getObjects() {
        readFromFiles();
        parseLine();
        return objects;
    }
    
    protected abstract void parseLine();
}

public class EmployeeArchive extends Archive<Employee> {
    
    public EmployeeArchive() {
        super("employees.csv");
    }
    
    @Override
    protected parseLine() {
        List<Employee> employees = new ArrayList<>();
        for (String line : super.lines) {
            employees.add(new Employee(line));
        }
        this.objects = employees;
    }
}

public class EmployeeServlet extends HttpServlet {
    
    private final IArchive<Employee> archive;
    
    public EmployeeServlet(IArchive<Employee> archive) {
        this.archive = archive;
    }
    
    public void doGet(HttpServletRequest req, HttpServletResponse res) {
        // ...
        List<Employee> employees = archive.getObjects();
        
        StringJoiner sj = new StringJoiner("[", "]");
        employees.forEach(sj::add);
        
        res.write(sj.toString());
    }
}
```

С энтузиазмом пишем сначала абстрактный класс и его наследника, который будет читать только работников из файла
'employees.csv'. 

Проанализируем написанное с точки зрения классического ООП.

У класса Архив есть состояние (прочитанные строки и распарсенные в объекты работники) и поведение - публичный
метод получить объекты из архива, скрытые от внешних глаз (привет, инкапсуляция) методы для чтения файла и 
абстрактный метод для парсинга из текста в объекты, который мы реализуем в класса Архив Работников. Все отлично.

Вы радостно пишите коллеге, что закончили свою часть и даже больше (вы еще же добавили метод по конвертации в 
json!) и коммитите ваш код в репозиторий проекта.

Ваш коллега используя сервлет и томкат (про которые вы тоже слышали) и используя ваш кода дописывает сервис. 

Вы с коллегой довольные собой 
![oop1](img/oop1.jpg)

В чем же причина? Сервлеты на каждый запрос используют новый тред, а ваш класс не синхронизирован. Справедливо,
правим наш класс Архив:

```java
public abstract class Archive<T> {
    
    protected List<T> objects = new ArrayList<>();
    
    protected List<String> lines = new ArrayList<>();
    
    private final String fileName;
    
    protected Archive(String fileName) {
        this.fileName = fileName;
    }
    
    protected void readFromFiles() {
        // здесь реализовано неблокирующее чтение.
        // писать я его не буду, потому что это сложнее, чем привычное блокирующее чтение из файла
        // но неблокирующее выбрано, чтобы не создавать непреодолимых узких мест в системе,
        // так как мы дальше коснемся многопоточки и производительности
        this.lines = unlockableReadLines;
    }
    
    public synchronized List<T> getObjects() { // (1)
        readFromFiles();
        parseLine();
        return objects;
    }
    
    protected abstract void parseLine();
}
```

Теперь вызывать метод (1) может только один поток и теперь падать ничего не должно. Отдаем на тесты и сервис не 
проходит нагрузчное тестирование. Так как теперь все треды ждут, пока один из них прочитает данные из файла.

Так как файл читается неблокирующее, то мы принимаем решение создавать на каждый запрос (он же тред) свой экземпляр
объекта `EmployeeArchive`, что решает проблему, правда ценой б*о*льшими затратами ОЗУ, так как каждый тред будет 
держать в памяти две коллекции - работники как строки и как объекты.

### Что не так с кодом

_Перед чтением причин 'а что не так' следует отметить, что приведенный пример кода довольно простой.
Из этого следует, что некоторые перечисленные ниже минусы будут не настолько очевидны, как хотелось бы
автору сего опуса, за что прошу меня извинить._

#### Наличие состояние и многопоточность. 

Большой процент сервисов (написанных на яве) работают многопоточно (например, томкат и аналоги создают на каждый 
запрос поток (thread), причем создают неявно). При многопоточности нам надо синхронизировать состояние между потоками.
Это ведет к усложнению кода, к просадке производительности (потому что потоков много, а объект синхронизации один) и 
другим неприятным вещам, которыми пугают детей программистов ![Screenshot](img/opp2.jpg)

#### Неявность состояния и поведения. 

Неявность в данном случае - это отсутствие возможности быстро 
определить в каком состоянии объект или что будет результатом работы его метода. Это сильно влияет на читаемоесть 
кода, его понимание и восприятие другим человеком. Будучи начинающим программистом вы писали код для себя. Теперь
вы пишите его для других и поэтому важно, чтобы ваш код был понятен не-программисту.

Разберем несколько подробней. Неявность состояния. 

```java
public class Main {
    public static void main(String[] args){ 
        List<Employee> employees = archive.getObjects(); // (1)
    }
}
```

Допустим, поток, в котором мы выполняем метод (1) был прерван (interrupted). В каком состоянии находится объект 
`archive`? Что будет, если мы вызовем метод (1) еще раз? У нас не ответа на эти вопросы.  

Другая проблема заключается в сложности реализации. Если в вашем классе несколько полей, и эти поля используются 
в разных методах (один метод пишет в поле, читает в другое и так далее), то очень тяжело понять последовательность 
этих шагов, не вдаваясь глубоко в детали. Алгоритм работы класса "размывается" по всему классу, и для понимания его 
работы необходимо внимательно изучить все содержимое. Это занимает достаточно большое время и человек уже забывает, 
зачем ему вообще сдался ваш класс.

#### Проблема с компизицией объектов

Что такое композиция объектов? По сути это когда один объект типа А имеет поле с типом В:
```java
import some.B;

class A {
    
    B field;
}
```
Композицию называют еще делегированием, так как часть задач внутри класса мы можем делегировать классу В, например:

```java
import some.B;

class A {
    
    B field;
    
    void doSomething() {
        out.println("Logic by class A");
        String someVar = b.doAnotherAction(); // делегируем расчет переменной классу В
        out.println("Logic by class А " + someVar);
    }
}
``` 
Так же еще называют поле field класса А зависимостью типа B.
 
Так вот, в чем же проблема при классическом ООП и композицией?
 
А нет у нас композиции в классическом ООП, мухаха \*злобно хохочет*. А как же так, спросите вы? А ООП ответит, но у 
вас же есть наследование и раз вам так нужен класс В, просто отнаследуйтесь от него.
 
```java
class A extends B {
    
    void doSomething() {
        out.println("Logic by class A");
        String someVar = super.doAnotherAction(); // делегируем расчет переменной классу В
        out.println("Logic by class А " + someVar);
    }
}
```

А представьте, что В имеет кучу полей и других завимостей, которые надо инициализировать, либо кучу методов, которые
нам и не нужны особо и так далее. Я, конечно, передергиваю, но композиции нет в принципах ООП, а наследование есть. 
И самое забавное, что в современном мире мы используем композицию везде, а наследование в столь редких случаях, 
что это даже забавно.

Если посмотреть более реалистичные примеры:

```java
public class SomeHandler {
    
    private final List<String> values = new ArrayList<>();
    
    private final JsonObjectVisitor visitor;
    
    public SomeHandler(JsonObjectVisitor visitor) {
        this.visitor = visitor;
    }
    
    public void handle(JsonObject json) {
       String type = json.getString("type");
       if ("department".equals(type)) {
           for (Json obj : json.getJsonArray()) { 
               String result = visitor.visit(obj.asJsonObject());
               values.add(result);
           }
       }
    }
    
    public List<String> getResult() {
        return this.values;
    }
}
```

Здесь одновременно используется и композиция (`SomeHandler` зависит от `JsonObjectVisitor`) и состояние (`values`).
Чтобы этот класс хоть как-то работал, нам на каждый вызов метода `handle` надо создавать новый объект класса 
`SomeHandler`. Но поле `visitor` у нас неизменяемое и мы должны хранить ссылку на `JsonObjectVisitor` в каждом объекте.
Что не так уж оптимально. Исходя из этого, видно, что композиция и классическое ООП с состоянияем не так сильно 
стыкаются между собой. Коночно, количество ссылок это мелочи и является больше придиркой, но все равно создает
впечатление неправильного дизайна, которое не дает засыпать вам каждой ночью.

### Резюме

Так почему же классическое ООП умерло? Да потому что те идеи, которые были заложены 20+ лет назад с течением времени
оказались не так хорошие и удобны в использовании. 

Состояние стало проблемой в многопоточности. Да, 20+ лет назад, 
когда ядро процессора было всего одно это было ок, никто не загонялся этим. А теперь, когда ядер процессоров в 
телефонах уже 8 и больше, это стало большой проблемой.

Сама идея использования состояния и поведения, которое использует состояние, тоже оказалась не такой приятной, так 
как при усложнении логики, систем в целом, такой код стал читаться и восприниматься гораздо сложнее. Да и использовать
его не очень удобно.

Поэтому, никто такой код уже не пишет (за редким исключением), просто многие уже даже не задумываются, как далеко
мы ушли от заветов \*дедушки Ленина*

## ООП next gen

Так, классическое ООП у нас мертво, так как же писать? Что взамен? А взамен у нас переосмысление принципов ООП с 
неплохой такой примесью функционального программирования. 

### Наследование

Ушло наследование. Конечно, во всех учебниках оно есть и официально никуда не ушло. Оно ушло из кода как 
принцип. Потому что принцип подразумевает свое использование гораздо чаще, чем те 5 классов у тебя в проекте,
3 из которых являются абстрактными, чтобы код не дублировать.


### Стиль программирования

Функциональная парадигма заменила процедурную. Как выглядит процедурная парадигма в жизни:

```java
public class ProcedureIsBad {
    
    private List<Integer> list = new ArrayList<>(asList(1,2));
    
    
    public void procedure(int i) { // (1)
        this.list.add(i); // когда мы вместо Integer используем int, 
        // то компилиятор превращает int в Integer.
        // Это называется auto-boxing. Теперь вы знаете больше (а может и нет, откуда мне знать)       
    }
    
    public void procedure(List<Integer> anotherList, int i) { // (2)
        anotherList.add(i);
    }
}
``` 

То есть, у нас есть методы, которые меняют состояние памяти (состояние объектов, они уже нас в памяти хранятся). 
Их легко узнать, потому что они чаще всего ничего не возвращают (`void`). Почему процедурная парадигма в контексте
ООП и java в частности это плохо? Потому что процедуры тяжело воспринимаются. Чтобы проиллюстрировать, давайте 
посмотрим на пример использования процедур:

```java
public class Main {
    public static void main(String[] args){
      List<Integer> list = new ArrayList<>(asList(1, 2, 3)); // А зачем создавать новый список, а не просто использовать
      // asList? Потому что коллекцию, которую возвращает метод asList нельзя модифицировать
      
      addElem(1);
      sort(Order.DESC);
      
      // Здесь куча другого кода
      
      
      
      
      // Серьезно, прям куча
      
      filter(list);
      
      // А теперь вспомни, что у тебя в этом листе.
      out.println(list);
    }
}
```

А давайте теперь в этом примере заменим процедурную парадигму на функциональную:

```java
public class Main {
    public static void main(String[] args){
      List<Integer> list = new ArrayList<>(asList(1, 2, 3)); 
      
      List<Integer> updatedList = addElem(list, 1);
      List<Integer> sortedList = sort(list, Order.DESC);
      
      // Здесь куча другого кода
      
      
      
      
      // Серьезно, прям куча
      
      List<Integer> filteredList = filter(list);
      
      // А теперь вспомни, что у тебя в этом листе.
      out.println(filteredList);
    }
}
```

Функциональная парадигма здесь больше касается сигнатур методов, в java никто особо не заморачивается с 
неизменяемостью (immutablity) объектов и side эффектами. 

```
Immutablity — способ написания классов, чье состояние невозможно изменить. Если очень хочется, то создается
такой же объект, но уже с нужными изменениями. Immutablity — когда в мире сдвигается камень, пересоздается Вселенная.

Side-effect — когда функция (метод) меняет чье-либо состояние. Фунцкия, которая не меняет чье-то состояние, называется
pure-функция \*расово верная функция*
``` 

Главное отличие данного способа от процедурного заключается в том, что метод возвращает результат своей работы. 
Даже если он просто изменил состояние переданного списка. Менять состояние вместо создания нового, конечно, 
не рекомендуется, но на практике каких-то особых последствий замечено не было, так как первоначальный вариант 
переменной обычно больше нигде не используется и покорно ждет сборщика мусора. 

Почему так важно возвращать результат?

Во-первых, нам не надо работать с изменяющимся состоянием. Мы получаем данные на вход, обрабатываем, отдаем на выход. 
Если же данные надо где-то хранить, то это не головная боль метода-обработчика, 
так как принцип Единой Ответственности никто не отменял. 

Во-вторых, мы получаем обратную связь при использовании метода. Если использование процерного стиля схоже с бросанием
камня в бездонный колодец и непонятно, произошло ли хоть что-нибудь, то при использововании фунционального - 
мы обязательно услышим всплеск. И сразу становится спокойнее, так как мы видим результат своих действий.   

А еще мы могли бы делать композицию функций или function chain (когда функции вызываются друг за другом), но синтаксис
явы слишком уродлив для этого. 

```java
public class Main {
    public static void main(String[] args){
      List<Integer> list = new ArrayList<>(asList(1, 2, 3)); 
      
      UnaryOperator<List<Integer>> addElemFunc = l -> addElem(l, 1);
      UnaryOperator<List<Integer>> sortFunc = l -> sort(l, Order.DESC);
      UnaryOperator<List<Integer>> filterFunc = Main::filter;
      
      List<Integer> filteredList = addElemFunc.andThen(sortFunc).andThen(filterFunc).apply(list); // function chain
      
      // А теперь вспомни, что у тебя в этом листе.
      out.println(filteredList);
    }
}
```

![Screenshot](img/oop3.jpg)


### Композиция объектов и интерфейсы

Если мы отказываемся от изменяемого состояния в классах (напомню, что Data Transfer Object, объекты для переноса данных,
классами являются только формально, так как не имеют никакого поведения и служат как кванты информации), используя 
функциональный стиль программирования, то композицию использовать становится проще. 

Более того, если мы не 
предусматриваем смену делегата (значения поля), то объект можно создать с неизменяемым состоянием. Если что-то не 
меняется, значит не сломается. 

Тогда получаем, что у нас есть класс с некоторой логикой, состояние которого зависит
от состояния его зависимостей. А если все зависимости будут написаны по тем же принципам, то и сама система будет
очень стабильной. 

Пример:

```java
public class SomeHandler {
    
    private final JsonObjectVisitor visitor;
    
    public SomeHandler(JsonObjectVisitor visitor) {
        this.visitor = visitor;
    }
    
    public List<String> handle(final JsonObject json) {
       String type = json.getString("type");
       if ("department".equals(type)) {
           List<String> values = new ArrayList<>();
           for (Json obj : json.getJsonArray()) { 
               String result = visitor.visit(obj.asJsonObject());
               values.add(result);
           }
           return values;
       }
       return Collections.emptyList();
    }
}
```

Мы избавились от изменяемого состояния класса, которое зависит теперь только от состояния объекта `visitor`.
Если при вызове метода класса пойдет что-то не так, например, произойдет прерывание потока (interrupt thread),
то мы можем дальше использовать этот объект, вызвав метод еще раз, а не гадая, в каком он состоянии.


При композиции объектов, ссылаться можно только на интерфейсы:

```java
interface B {}
interface A {}

class AImpl implements A {
    
    private final B requiredDependency;
    
    private B optionalDependency;
    
    public AImpl(B b) {
        this.requiredDependency = Objects.requireNonNull(b);
    }
    
    public AImpl setOptionalDependency(B b) {
        this.optionalDependency = b;
        return this;
    }
}
```

Все зависимости класса делятся на две группы:

* Обязательные. Без них выполнение задачи классом невозможно.
* Опциональные. Являются вспомогательными, успешность выполнение задачи классом от них не зависит

Например:

```java
public class AuthorService implements Service<Author> {
    
    // Обязательная зависимость. Без репозитория мы с авторами не сможем работать
    private final AuthorRepository authorRepository;
    
    // Опциональная. Если его нет, значит кидаем RuntimeException
    private SQLExceptionTranslator translator;
    
    public AuthorService(AuthorRepository authorRepository) {
        this.authorRepository = Objects.requireNonNull(authorRepository);
    }
    
    public AuthorService setTranslator(SQLExceptionTranslator translator) {
        this.translator = translator;
        return this;
    }
    
    public Optional<Author> findAuthor(String name) {
        try {
            return authorRepository.findByName(name);
        } catch (SQLException ex) {
            if (translator != null) {
                throw translator.translate(ex);
            }
            throw new RuntimeException(ex);
        }
    }
}
``` 

Из правила "ссылаться можно только на интерфейсе" следует, что каждый класс должен реализовывать интерфейс.

## Резюме

Мы немного вспомнили классическое ООП, знакомое каждому программисту. Кошечки, собачки 
и [InterpreterClientDecoratorMapper](https://projects.haykranen.nl/java/).

Мы разобрали недостатки подходов классического ООП, из-за которых незаметно для окружающих оно мутировало в нечто 
среднее функциональным и классическим ООП подходами. Да, есть люди, пишущее еще в классическом виде, но обычно
это код очень больно поддерживать и их в тайне все ненавидят (как не парадоксально, даже те, кто сам так пишет).

В этой главе мы описали не то, как сейчас все пишут код, а к чему надо стремиться, чтобы писать гибкие, понятные и 
поддерживаемые системы. 



