# Современное ООП или почему классическое ООП мертво?

## Классическое ООП, которое мы все знаем

Как объясняют ООП в большинстве случаев? 

Есть класс `Animal`, от него наследуются `Cat` и `Dog`. Животное может иметь цвет, имя, издавать звуки и бегать.

```java
abstract class Animal {
    
   protected String name;
    
   protected Animal(String name) {
       this.name = name;
   }
    
   public abstract void run();
    
   public respondName(String anyName) {
       if (name.equals(anyName)) {
           run();
       }
   }
}

class Cat extends Animal {
    
    public Cat(String name) {
        super(name);
    }
    
    @Override
    public void run() {
       System.out.println("Дык дык дык");
    }
     
    public void climbTree() {
        // cat can to climb a tree
    }
}

class Dog extends Animal {
    
    public Cat(String name) {
        super(name);
    }
    
    @Override
    public void run() {
       System.out.println("*звук бегающей собаки*");
    }
    
    public void bringBall() {
        // dog can bring the ball
    }
}

public class Main {
    public static void main(String[] args){
      for (Animal animal : asList(new Cat("Barsik", RED), new Dog("GoodBoy", BLUE))) {
          animal.respondName("Barsik");        
      }
    }
}

// printed: Дык дык дык
```

Каждый класс представляет собой объект реального мира, у которого есть какие-то характеристики и поведение. 

В этом сниппете кода можно увидеть все принципы ООП:

* Наследование. Кошка и собака наследуют все черты, характерные для класса Животные, который мы описали. Они не 
только могут откликаться на свои имя и  бегать, но и имеют уникальные черты, например, кошка может забираться 
на дерево, а собака - приносить мячик.
* Инкапсуляция. Здесь инкапулирован поле с именем, его значение вне класса мы получить не можем.
* Полиморфизм. Не зависимо от типа животного, кошка или собака, мы можем окликнуть их по имени, так как это 
свойственно классу Животные.
* Абстракция. При создании классов мы взяли только свойства и поведение, которые нам необходимы, а не описывали
все детально. То есть, наш класс Животное - это некая абстракция над реальным животным, над объектом реального мира.

Не так сложно, да? Но что же могло пойти не так...

## Почему классическое ООП умерло?

### Маленький жизненный пример

Вы устроились на работу программистом Java и ваше первое большое и ответственное задание - написать с коллегой
REST сервис, который отдает информацию о офисных работниках фирмы. Информация о работниках лежит в текстовых файлах 
на файловом сервере компании. Ваш коллега написать REST часть (ок, гугл, что такое REST), ваша задачи прочитать
из файлов работников.

Так, погодите, а где кошечки и собачки? Эй? Хм, хорошо. у нас есть хотя бы класс Работник, да? Отлично, давайте
напишем для него класс.

```java
public class Employee {
    private Long id;
    private String name;
} 
```

Так, мы создали класс, добавили туда пару полей, заинкапсулировали их. Осталось добавить пару действий, которые
могут выполнять наши работники и все будет отлично. Хм. Так, мы же пишем REST сервис, а он обычно отдает информацию
в JSON (другие программисты говорили об этом в курилке). Добавим метод конвертации в json, как раз прям классика
будет:

```java
public class Employee {
    private Long id;
    private String name;
    
    public String toJson() {
        return "{\"id\": " + id + ", \"name\" : " + name + " }";
    }
} 
```

А что у нас говорит ООП? Классы моделируют объекты реального мира, а умеют ли у нас работник компании
преобразовывать себя в Json? Что-то сомнительно. Но это мелочи жизни, давайте пойдем дальше.

Работники у нас хранятся в файлах и нам их надо оттуда достать. Давайте подумаем, как это сделать в рамках
классического ООП.

Если мы добавили метод для преобразования данных в json, почему бы не добавить метод для чтения
работника из файла? Нет, это глупо, работник же не может сам себя вычитать из файла. Значит, это должен делать
кто-то другой. Но мы можем сделать конструктор для класс Работник, который принимает строку из файла и создать класс
Архив, который будет читать работников из файла:
```java
public class Employee {
    
    private Long id;
    private String name;
    
    public Employee(String line) {
        String[] parts = line.split(",");
        this.id = Long.parseLong(parts[0]);
        this.name = parts[1];
    }
    
    public String toJson() {
        return "{\"id\": " + id + ", \"name\" : " + name + " }";
    }
} 

public interface IArchive<T> {
    
     List<T> getObjects();
     
}

public abstract class Archive<T> {
    
    protected List<T> objects = new ArrayList<>();
    
    protected List<String> lines = new ArrayList<>();
    
    private final String fileName;
    
    protected Archive(String fileName) {
        this.fileName = fileName;
    }
    
    protected void readFromFiles() {
        // здесь реализовано неблокирующее чтение.
        // писать я его не буду, потому что это сложнее, чем привычное блокирующее чтение из файла
        // но неблокирующее выбрано, чтобы не создавать непреодолимых узких мест в системе,
        // так как мы дальше коснемся многопоточки и производительности
        this.lines = unlockableReadLines;
    }
    
    public List<T> getObjects() {
        readFromFiles();
        parseLine();
        return objects;
    }
    
    protected abstract void parseLine();
}

public class EmployeeArchive extends Archive<Employee> {
    
    public EmployeeArchive() {
        super("employees.csv");
    }
    
    @Override
    protected parseLine() {
        List<Employee> employees = new ArrayList<>();
        for (String line : super.lines) {
            employees.add(new Employee(line));
        }
        this.objects = employees;
    }
}

public class EmployeeServlet extends HttpServlet {
    
    private final IArchive<Employee> archive;
    
    public EmployeeServlet(IArchive<Employee> archive) {
        this.archive = archive;
    }
    
    public void doGet(HttpServletRequest req, HttpServletResponse res) {
        // ...
        List<Employee> employees = archive.getObjects();
        
        StringJoiner sj = new StringJoiner("[", "]");
        employees.forEach(sj::add);
        
        res.write(sj.toString());
    }
}
```

С энтузиазмом пишем сначала абстрактный класс и его наследника, который будет читать только работников из файла
'employees.csv'. 

Проанализируем написанное с точки зрения классического ООП.

У класса Архив есть состояние (прочитанные строки и распарсенные в объекты работники) и поведение - публичный
метод получить объекты из архива, скрытые от внешних глаз (привет, инкапсуляция) методы для чтения файла и 
абстрактный метод для парсинга из текста в объекты, который мы реализуем в класса Архив Работников. Все отлично.

Вы радостно пишите коллеге, что закончили свою часть и даже больше (вы еще же добавили метод по конвертации в 
json!) и коммитите ваш код в репозиторий проекта.

Ваш коллега используя сервлет и томкат (про которые вы тоже слышали) и используя ваш кода дописывает сервис. 

Вы с коллегой довольные собой 
![oop1](img/oop1.jpg)

В чем же причина? Сервлеты на каждый запрос используют новый тред, а ваш класс не синхронизирован. Справедливо,
правим наш класс Архив:

```java
public abstract class Archive<T> {
    
    protected List<T> objects = new ArrayList<>();
    
    protected List<String> lines = new ArrayList<>();
    
    private final String fileName;
    
    protected Archive(String fileName) {
        this.fileName = fileName;
    }
    
    protected void readFromFiles() {
        // здесь реализовано неблокирующее чтение.
        // писать я его не буду, потому что это сложнее, чем привычное блокирующее чтение из файла
        // но неблокирующее выбрано, чтобы не создавать непреодолимых узких мест в системе,
        // так как мы дальше коснемся многопоточки и производительности
        this.lines = unlockableReadLines;
    }
    
    public synchronized List<T> getObjects() { // (1)
        readFromFiles();
        parseLine();
        return objects;
    }
    
    protected abstract void parseLine();
}
```

Теперь вызывать метод (1) может только один поток и теперь падать ничего не должно. Отдаем на тесты и сервис не 
проходит нагрузчное тестирование. Так как теперь все треды ждут, пока один из них прочитает данные из файла.

Так как файл читается неблокирующее, то мы принимаем решение создавать на каждый запрос (он же тред) свой экземпляр
объекта `EmployeeArchive`, что решает проблему, правда ценой б*о*льшими затратами ОЗУ, так как каждый тред будет 
держать в памяти две коллекции - работники как строки и как объекты.

### Что не так с кодом

_Перед чтением причин 'а что не так' следует отметить, что приведенный пример кода довольно простой.
Из этого следует, что некоторые перечисленные ниже минусы будут не настолько очевидны, как хотелось бы
автору сего опуса, за что прошу меня извинить._

#### Наличие состояние и многопоточность. 

Большой процент сервисов (написанных на яве) работают многопоточно (например, томкат и аналоги создают на каждый запрос поток (thread), причем
создают неявно). При многопоточности нам надо синхронизировать состояние между потоками. Это ведет к усложнению кода, к просадке
производительности (потому что потоков много, а объект синхронизации один) и другим неприятным вещам,
которыми пугают детей программистов ![Screenshot](img/opp2.jpg)

#### Неявность состояния и поведения. 

Неявность в данном случае - это отсутствие возможности быстро 
определить в каком состоянии объект или что будет результатом работы его метода. Это сильно влияет на читаемоесть 
кода, его понимание и восприятие другим человеком. Будучи начинающим программистом вы писали код для себя. Теперь
вы пишите его для других и поэтому важно, чтобы ваш код был понятен не-программисту.

Разберем несколько подробней. Неявность состояния. 

```java
public class Main {
    public static void main(String[] args){ 
        List<Employee> employees = archive.getObjects(); // (1)
    }
}
```

Допустим, поток, в котором мы выполняем метод (1) был прерван (interrupted). В каком состоянии находится данный
объект? Что будем, если мы вызовем метод (1) еще раз? У нас не ответа на эти вопросы.  

Другая проблема заключается в сложности реализации. Один из принципов ООП нам говорит, что состояние объекта 
должно быть инкапсулировано. Это замечательный принцип, но ровно до того момента, когда вам необходимо понять, 
как работает метод (1). 

