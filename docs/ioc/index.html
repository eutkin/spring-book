<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>Spring IoC - Spring Guide</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="generator" content="mkdocs-1.0.4, mkdocs-gitbook-1.0.7">

<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon">
<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta rel="next" href="" />
<link href="../css/style.min.css" rel="stylesheet"> 
</head>

<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input type="text" placeholder="Type to search" />
</div> <!-- end of book-search-input -->

<nav role="navigation">
<ul class="summary">
<li>
<a href=".." target="_blank" class="custom-link">Spring Guide</a>
</li>
<li class="divider"></li>
<li class="chapter" data-path="">
<a href="..">Введение</a>
<li class="chapter active" data-path="ioc/">
<a href="./">Spring IoC</a>
<li class="chapter" data-path="oop/">
<a href="../oop/">Современное ООП или почему классическое ООП мертво?</a>
<li class="divider"></li>



<li><a href="http://www.mkdocs.org">
Published with MkDocs
</a></li>

<li><a href="https://github.com/GitbookIO/theme-default">
Theme by GitBook
</a></li>
</ul>

</nav>

</div> <!-- end of book-summary -->

<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">

<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="." ></a>
</h1>

</div> <!-- end of book-header -->

<div class="page-wrapper" tabindex="-1" role="main">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">

<section class="normal markdown-section">



<h1 id="spring-ioc">Spring IoC</h1>
<h2 id="_1">Контейнер бинов и способы его конфигурации</h2>
<h3 id="_2">Вступление</h3>
<p>Что такое бин (<code>bean</code>)? Бин - это класс, жизненным циклом которого управляет контейнер спринга.</p>
<p>Основная задача контейнера бинов заключается в хранении бинов и управлении их жизненным циклом.</p>
<p>Способ, с помощью которого контейнер управляет жизненным циклом, задаётся пользователем через <em>конфигурацию</em> бинов 
либо самим контейнером способом по умолчанию. </p>
<p>Единственное необходимое условие включения класса в качестве 
бина под управлением контейнера: пользователь явно должен указать Spring'у, какие классы будут им 
управляться.</p>
<p>Делегирование управления жизненным циклом класса позволяет избавиться от большой части рутинного кода,
полноценно следовать принципу инвертирования зависимостей и сосредоточить внимание на бизнес-коде, а не на 
его инфраструктурной части.</p>
<p>Все бины приложения, как пользовательские, так и служебные, называются контекстом приложения и хранятся 
в <code>ApplicationContext</code>.</p>
<h3 id="_3">Конфигурация контейнера бинов</h3>
<p>Однако, чтобы эффективно управлять жизненным циклом, спрингу необходимы подсказки от пользователя. Эти подсказки
описываются в <em>конфигурации бинов</em> в виде декларативного описания: как создавать объект, в какие поля
необходимо внедрить зависимости, какие методы вызывать после создания и перед уничтожением объекта и т.д.</p>
<p>Конфигурации могут иметь зависимости друг на друга посредством импортирования. С помощью этого механизма можно
иметь конфигурации всех типов, импортировав их в одну рутовую конфигурацию, через которую будет 
инициализироваться Spring контекст.</p>
<h3 id="_4">Виды конфигурации бинов</h3>
<p>Есть несколько способов это сделать, давайте их перечислим:</p>
<ul>
<li>XML конфигурация. Описание бинов лежит в xml файле с использованием специального синтаксиса. Считается
устаревшим, используется только стариками, которые не хотят идти в ногу со временем. <ul>
<li>Плюсы: <ul>
<li>можно перегружать в рантайме</li>
</ul>
</li>
<li>Минусы: <ul>
<li>можно перегружать в рантайме</li>
<li>большой объем, многословный синтаксис</li>
<li>нет типизации, но спасает IDE</li>
</ul>
</li>
</ul>
</li>
<li>Java-class конфигурация. Описание бинов находится в java классе с использованием различных 
аннотаций.<ul>
<li>Минусы: <ul>
<li>теперь вместо кучи xml пишем кучу кода</li>
<li>нельзя перегружать в рантайме </li>
</ul>
</li>
<li>Плюсы:<ul>
<li>типизация, сложно ошибиться</li>
<li>код писать привычней и приятней, чем xml</li>
</ul>
</li>
</ul>
</li>
<li>Groovy скрипт конфигурация. Описание бинов лежит в groovy скрипте с использованием DSL. Появился 
со Spring 4.<ul>
<li>Минусы:<ul>
<li>им никто не пользуется</li>
<li>требует груви зависимостей</li>
</ul>
</li>
<li>Плюсы:<ul>
<li>есть типизация</li>
<li>можно перегружать в рантайме (ха-ха, прощай xml)</li>
<li>немногословный синтаксис (привет, java-конфигурация)         </li>
</ul>
</li>
</ul>
</li>
<li>Kotlin конфигурация. Появилась в Spring 5. Бины описываются с помощью DSL, написанном на котлине. Тоже скрипт. По сути 
всё то же самое, что и груви, только типизация не динамическая, а статическая, что не может не радовать.
Must have при написании проектов Spring 5 + Kotlin.</li>
</ul>
<h3 id="_5">Примеры</h3>
<p>Xml конфигурация:</p>
<pre><code class="xml">&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;

&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot;
   xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;

   &lt;bean id = &quot;converterBean&quot; class = &quot;NumberToCharacterConverter&quot; destroy-method=&quot;close&quot;&gt;
   &lt;/bean&gt;

   &lt;bean id=&quot;someService&quot; class=&quot;SomeServiceImpl&quot; init-method=&quot;init&quot; scope=&quot;prototype&quot;&gt;
     &lt;constructor-arg&gt;converter&lt;/constructor-arg&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>

<p>Java-class конфигурация:     </p>
<pre><code class="java">@Configuration
public class Beans {

    @Bean(destroyMethod = &quot;close&quot;)
    public Converter&lt;Number, Character&gt; converterBean() {
        return new NumberToCharacterConverter();
    }

    @Bean(initMethod = &quot;init&quot;)
    @Scope(BeanDefinition.SCOPE_PROTOTYPE)
    public SomeService someService(Converter&lt;Number, Character&gt; converter) {
        return new SomeServiceImpl(converter);
    }
}
</code></pre>

<p>Groovy конфигурация:</p>
<pre><code class="groovy">beans {
    converterBean(NumberToCharacterConverter) {bean -&gt;
        bean.destroyMethod = &quot;close&quot; 
    }

    someService(SomeServiceImpl, converter : converterBean) {bean -&gt;
        bean.initMethod = &quot;init&quot; 
        bean.scope = &quot;prototype&quot;     
    }

}
</code></pre>

<p>Kotlin конфигурация:</p>
<pre><code class="kotlin">fun beans() = beans {

    bean&lt;NumberToCharacterConverter&gt;(&quot;converterBean&quot;)

    bean&lt;SomeService&gt;(&quot;someService&quot;) {
        SomeServiceImpl(ref())
    }
}
</code></pre>

<p>(Да, я не знаю, где в котлине destroy, init методы, так как даже примеры оказалось найти не так просто.)</p>
<p>Отметим ещё способ объявления бина через аннотации. Технически это сложно назвать способом конфигурации,
так как он довольно сильно отличается от других способов. Идея этого способа состоит в том, чтобы в 
самом классе расставить аннотации и указать на него спрингу. Спринг считывает определение бина из этих
аннотаций, и класс попадает по управление контейнером.</p>
<pre><code class="java">@Component
public class NumberToCharacterConverter implements Converter&lt;Number, Character&gt; {

    @Override
    public Character convert(Number source) {
        return (char) source.shortValue();
    }

    @PreDestroy
    private void destroy() {
        // Это приватный метод-деструктор. Да, destroy методы и init могут быть приватными.
        // Он нужен, чтобы закрывать различные ресурсы.
    }
}

@Service // Это псевдоним для @Component. Он нужен, чтобы подчеркнуть, что в классе находится бизнес-логика.
public class SomeServiceImpl implements SomeService {

    private final Converter&lt;Number, Character&gt; converter;

    public SomeServiceImpl(Converter&lt;Number, Character&gt; converter) {
        this.converter = converter;
    }

    @PostConstruct
    public void init() {
        // Это так называемый второй конструктор. 
        // Он нужен, чтобы выполнить какие-то инициализирующие действия уже после
        // инжекта всех зависимостей.
    }

    public void businessLogic() {
        converter.convert(1);
    }
}
</code></pre>

<h3 id="_6">Резюме</h3>
<p>Как видно из примеров, мы можем указать спрингу имя бина (какой именно класс мы передаем под его 
управление), описать его зависимости, <em>init</em>, <em>destroy</em> методы (выполняются после инициализации и 
до уничтожения соответственно).</p>
<p>Далее мы рассмотрим непосредственно правило внедрения зависимостей.</p>
<h2 id="spring-ioc_1">Инверсия зависимостей со Spring IoC</h2>
<h3 id="_7">Инициализация контекста</h3>
<p>В данной части рассмотрим работу со Spring IoC (inversion of control) - одной из реализаций принципа 
Dependency Inversion.</p>
<p>Как же работать с контекстом спринга? Для начала его необходимо проинициализировать. </p>
<p>Способ его инициализации зависит от способа конфигурации. </p>
<p>Далее мы будем рассматривать все примеры на Java конфигурации, потому что это самый распространенный пример
конфигурации (процентов так 
<a href="http://lurkmore.to/95%25_%D0%BD%D0%B0%D1%81%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%E2%80%94_%D0%B8%D0%B4%D0%B8%D0%BE%D1%82%D1%8B">95%</a> 
в относительно новых проектах). Остальные варианты рассмотрите самостоятельно.</p>
<pre><code class="java">@Configuration
public class BeansConfiguration {

}

public class Main {

    public static void main(String[] args){
      final ApplicationContext ctx = new AnnotationConfigApplicationContext(BeansConfiguration.class);
    }
}
</code></pre>

<p>В данном примере, <code>BeansConfiguration</code> - это рутовый класс java-class конфигурации контекста.</p>
<p>В переменной <code>ctx</code> получим инициализированный контекст приложения.</p>
<h3 id="_8">Вводная</h3>
<p>Определимся с несколькими терминами:</p>
<ul>
<li>
<p><em>Зависимость класса A типа B</em> -- класс А имеет поле типа B (где B должен быть обязательно интерфейсом, 
за редким исключением).</p>
</li>
<li>
<p><em>Обязательная зависимость</em> -- зависимость, без которой основная задача класса не выполнима. Например, если
некоторый сервис оперирует данными, то зависимость от репозитория будет считаться обязательной.</p>
</li>
<li>
<p><em>Опциональная зависимость</em> -- зависимость, которая не вносит какой-либо весомый вклад в выполнении задачи класса, а 
является вспомогательной, например, какой-либо фильтр, транслятор исключений и так далее. Без данной зависимости
сервис все равно способен выполнить свою бизнес-задачу. </p>
</li>
<li>
<p><em>Автосвязывание</em> -- если у класс А есть зависимость от типа В и есть только один бин с этим типом, то Spring
автоматически внедрит зависимость, подставив бин типа В.</p>
</li>
</ul>
<p>Для примера опишем несколько классов и интерфейсов. Из предыдущих лекций вы должны помнить, что любой 
класс, у которого есть поведение (то есть, в его методах заключена логика), должен реализовывать интерфейс,
в котором данная логика имеет формальный вид. Приступим:</p>
<pre><code class="java">public interface Repository&lt;T, ID&gt; {} // (1)

public class FileStoreRepository implements Repository&lt;Author, Long&gt; {} // (2)

public class JpaRepository implements Repository&lt;Author, Long&gt; {} // (3)
</code></pre>

<pre><code class="java">public interface AuthorService {} // (4)
</code></pre>

<pre><code class="java">public interface PrettyPrinter {}  // (5)

public class CapitalizePrettyPrinter implements PrettyPrinter {}  // (6)
</code></pre>

<p>Для простоты мы не указываем методы в интерфейсах. Посмотрим на пример использования: </p>
<pre><code class="java">public class AuthorServiceImpl implements AuthorService {  // (7)

    private final Repository&lt;Author, Long&gt; repository; // (8)

    private PrettyPrinter prettyPrinter; // (9)

    private String fieldDependency; // (10)

    public AuthorServiceImpl(Repository&lt;Author, Long&gt; repository) { // (11)
        this.repository = requiredNonNull(repository, &quot;Repository must be not null&quot;); // (12)
    }

    @Override
    public Author getAuthor(Long authorId) {
        Author author = repository.findOne(authorId);

        if (prettyPrinter != null) {  
            String prettyName = prettyPrinter.doNameAsPretty(author.getName());
            author.setName(prettyName);
        }
        return author;
    }

    public void setPrettyPrinter(PrettyPrinter prettyPrinter) {  // (13)
        this.prettyPrinter = prettyPrinter;
    }
}
</code></pre>

<pre><code class="java">@Configuration
public class BeansConfiguration { // (14)

}

public class Main {

    public static void main(String[] args){
      final ApplicationContext ctx = new AnnotationConfigApplicationContext(BeansConfiguration.class);
    }
}
</code></pre>

<p>Классы (2) и (3) представляют собой репозитории для манипуляции сущностями авторов в файловой системе и базе данных 
соответственно. Сервисы (4) и (5) инкапсулируют в себе некоторую бизнес-логику, которую реализуют классы (6) и (7).</p>
<p>Класс (14) является java конфигурацией.</p>
<p>Перед примерами работы с конфигурацией, разберем класс <code>AuthorServiceImpl</code> (7).</p>
<p>Согласно терминам из начала лекции: </p>
<ul>
<li>Зависимость <code>repository</code> (8) является обязательной зависимостью, чье наличие является крайне важной. Поэтому
она является финальным полем, инициализируется через конструктор и дополнительно проверяется на null (12). </li>
<li>Зависимость <code>prettryPrinter</code> (9) является опциональной, так как она не влияет на выполнение бизнес-задачи 
сервисом. Для ее внедрения служит <code>setter</code> (13).</li>
<li>Зависимость <code>fieldDependency</code> (10) нужна, чтобы показать как пример внедрения через поле. Как мы увидим это ниже,
то через java конфиг нельзя сделать это легко и непринужденно. Несмотря на то, что это очень популярный способ 
внедрения, этот способ является в корне неверным и не рекомендуется самим Pivotal (разработчиком и вендором спринга).</li>
</ul>
<p>Наша задача - передать контроль за жизненным циклом перечисленных классов контексту спринга. </p>
<h3 id="java-class">Конфигурация через java-class</h3>
<h4 id="1">Пример 1</h4>
<p>Разберём следующий пример. Сервис <code>AuthorService</code> (4) при вызове метода <code>getAuthor(authorId)</code> должен возвращать
сущность автора. Также необходимо выводить авторов в лог в определенном формате. Авторы должны храниться в файловой системе. Наша задача - настроить конфигурацию спринга таким 
образом, чтобы получить приложение, соответствующее условиям задачи. </p>
<p>Идём в конфигурацию (14) и добавляем необходимые бины:</p>
<pre><code class="java">@Configuration
public class BeansConfiguration { // (14)

    @Bean(name = &quot;authorService&quot;) // (15)
    public AuthorService authorService(
            Repository&lt;Author, Long&gt; repository, // (16)
            @Autowired(required = false /* 17 */ ) PrettyPrinter prettyPrinter // (18) 
        ) {
        AuthorService authorService = new AuthorServiceImpl(repository);
        if (prettyPrinter != null) {
            authorService.setPrettyPrinter(prettyPrinter); // (19)
        }
        return authorService; // (20)
    }   

    @Bean
    public Repository&lt;Author, Long&gt; fileRepository() { // (21)
        return new FileStoreRepository();
    }

    @Bean
    public PrettyPrinter prettyPrinter() { // (22)
        return new CapitalizePrettyPrinter();
    }
}
</code></pre>

<p>Теперь разберём пример чуть подробнее. В методе (15), который в спринге называется <code>factory-method</code>, создаётся
<code>authorService</code>. Для его создания нам надо получить его зависимости. Чтобы получить ссылки на другие бины, которые нужны
для создания сервиса, мы пишем их как аргументы (16),(18) factory метода. Так как <code>PrettyPrinter</code> (5) является 
опциональной зависимостью, то мы подсказываем спрингу (17), чтобы он не выдавал ошибку, если данного бина не будет.</p>
<p>После этого мы можем получить через спринг-контекст бин <code>authorService</code> и автора из файловой системы:</p>
<pre><code class="java">public class Main {

    public static void main(String[] args){
      final ApplicationContext ctx = new AnnotationConfigApplicationContext(BeansConfiguration.class);
      AuthorService authorService = ctx.getBean(AuthorService.class);
      Author authorFromFile = authorService.getAuthorId(1L);
    }
}
</code></pre>

<p>В итоге мы получили искомое приложение, написав спринг конфигурацию.</p>
<h4 id="2">Пример 2</h4>
<p>По мере развития нашего проекта, его аудитория разрослась, и теперь мы больше не можем позволить себе хранить авторов в файлах.
Бизнес хочет аналитику, и в этот чёрный день вам создали тикет мигрировать в базу данных. Так же мы решили отказаться
от вывода авторов в лог, то есть от <code>PrettyPrinter</code> (5). </p>
<p>Опустим перенос существующих данных. Нам необходимо изменить способ доступа к данным и вместо файлов использовать 
базу данных. Для этих целей нам пригодится <code>JpaRepository</code> (3), который так же реализует наш интерфейс <code>Repository</code>. 
Поэтому изменим спринг конфигурацию таким образом, чтобы вместо файлового репозитория использовался 
jpa репозиторий:</p>
<pre><code class="java">@Configuration
public class BeansConfiguration { // (14)

    @Bean(name = &quot;authorService&quot;) // (15)
    public AuthorService authorService(
            Repository&lt;Author, Long&gt; repository, // (16)
            @Autowired(required = false /* 17 */ ) PrettyPrinter prettyPrinter // (18) 
        ) {
        AuthorService authorService = new AuthorServiceImpl(repository);
        if (prettyPrinter != null) {
            authorService.setPrettyPrinter(prettyPrinter); // (19)
        }
        return authorService; // (20)
    }   

    @Bean
    public Repository&lt;Author, Long&gt; jpaRepository() { // (23)
        return new JpaRepository();
    }

}
</code></pre>

<p>Мы удалили бин <code>fileRepository</code> (21) и <code>prettyPrinter</code> (22) за ненадобностью и добавили новый бин
<code>jpaRepository</code> (23). Если внимательно посмотреть на конфигурацию <code>authorService</code> (15), то можно заметить, что
метод не изменился, так как мы заранее предусмотрели возможность отсутствия <code>prettyPrinter</code> и ссылаемся не
на конкретный репозиторий, а на интерфейс.</p>
<h4 id="_9">Резюме</h4>
<p>Мы рассмотрели на двух примерах небольшой период жизни, за который проект подвергся 
изменениям. Очень важный момент в этих примерах состоит в том, что, несмотря на изменения требований, менялась
только конфигурация спринга, а ранее написанный код (1) - (13) не менялся. </p>
<p>Это происходит потому, что мы использовали такие SOLID принципы, как принцип единой ответственности и принцип
открытости-закрытости, согласно которым каждый класс выполяет одну задачу и закрыт для модификаций, но открыт 
для расширения.  </p>
<h3 id="spring">Конфигурация через аннотации или "Spring, сделай все за меня, братишка"</h3>
<p>Теперь посмотрим, как всё будет выглядеть, если сконфигурировать спринг через аннотации над самими классами:</p>
<pre><code class="java">public interface Repository&lt;T, ID&gt; {} // (1)

@Repository // (2)
public class FileStoreRepository implements Repository&lt;Author, Long&gt; {} // (3)

public class JpaRepository implements Repository&lt;Author, Long&gt; {} // (4)
</code></pre>

<pre><code class="java">public interface AuthorService {} // (5)
</code></pre>

<pre><code class="java">public interface PrettyPrinter {}  // (6)

@Component // (7)
public class CapitalizePrettyPrinter implements PrettyPrinter {}  // (8)
</code></pre>

<p>Для простоты мы не указываем методы в интерфейсах. Посмотрим на пример использования: </p>
<pre><code class="java">@Service // (9)
public class AuthorServiceImpl implements AuthorService {  // (10)

    private final Repository&lt;Author, Long&gt; repository; // (11)

    private PrettyPrinter prettyPrinter; // (12)

    @Autowired // (13)
    private String fieldDependency; // (14)

    public AuthorServiceImpl(Repository&lt;Author, Long&gt; repository) { // (15)
        this.repository = requiredNonNull(repository, &quot;Repository must be not null&quot;); // (16)
    }

    @Override
    public Author getAuthor(Long authorId) {
        Author author = repository.findOne(authorId);

        if (prettyPrinter != null) {  // (13)
            String prettyName = prettyPrinter.doNameAsPretty(author.getName());
            author.setName(prettyName);
        }
        return author;
    }

    @Autowired(required = false) // (17)
    public void setPrettyPrinter(PrettyPrinter prettyPrinter) {  // (18)
        this.prettyPrinter = prettyPrinter;
    }
}
</code></pre>

<pre><code class="java">@Configuration
@ComponentScan(&quot;здесь имя пакета, где лежат ваши бины&quot;) // (19)
public class BeansConfiguration { // (20)

}

public class Main {

    public static void main(String[] args){
      final ApplicationContext ctx = new AnnotationConfigApplicationContext(BeansConfiguration.class);
    }
}
</code></pre>

<p>Посмотрим, что изменилось:</p>
<ul>
<li>
<p>В <code>FileStoreRepository</code> (3) добавили аннотацию <code>@Repository</code> (2), которая говорит спрингу, что жизненный цикл
данного класса передают под управлению спринга. Данная аннотация является аналогом аннотации <code>@Component</code>, которую
рассмотрим чуть ниже. В отличии от неё, аннотацией <code>@Repository</code> помечаются бины, которые осуществляют операции по 
манипулированию сущностями в хранилищах.</p>
</li>
<li>
<p>Над <code>CapitalizePrettyPrinter</code> (8) появилась аннотация <code>@Component</code> (7). Этой аннотацией помечаются все классы, 
которые мы хотим сделать бинами. Этой аннотацией следуют помечать те классы, которые не имеют отношения к хранению
данных или бизнес-логике. Например, какие-то инфраструктурные классы.</p>
</li>
<li>
<p>Над сервисом <code>AuthorServiceImpl</code> (10) появилась аннотация <code>@Service</code> (9). Этой аннотацией помечаются все бины,
которые инкапсулируют в себе бизнес-логику. </p>
</li>
</ul>
<p>Теперь разберём, как показать спрингу, какие зависимости мы хотим внедрить.</p>
<p>Зависимость от <code>Repository</code> (11) мы получаем через конструктор (15); здесь ничего дополнительно указывать не надо,
т.к. чтобы создать объект сервиса, спрингу необходимо внедрить зависимость, указанную в аргументах
конструктора.</p>
<p>Зависимость от <code>PrettryPrinter</code> (12) мы получаем через сеттер (18), так как данная зависимость является 
опциональной. Для автосвязывания мы используем аннотацию <code>@Autowired</code> с флагом required = false (17), чтобы спринг
не выдавал ошибку в случае отсутствия бина.</p>
<p>Чтобы внедрить зависимость в поле <code>fieldDependency</code> (14), мы также используем данную аннотацию (13). Однако, ещё раз 
повторю, внедрять зависимости через поле запрещено (если это, конечно, не тесты).</p>
<p>Последним шагом укажем в конфигурации (20) аннотацию <code>@ComponentScan</code> (19), которая подскажет спрингу, в 
каком пакете искать наши бины.</p>


</section>
</div> <!-- end of search-noresults -->
<div class="search-results">
<div class="has-results">

<h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
<ul class="search-results-list"></ul>

</div> <!-- end of has-results -->
<div class="no-results">

<h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>

</div> <!-- end of no-results -->
</div> <!-- end of search-results -->
</div> <!-- end of book-search-results -->

</div> <!-- end of page-inner -->
</div> <!-- end of page-wrapper -->

</div> <!-- end of body-inner -->

</div> <!-- end of book-body -->
<script src="../js/main.js"></script>
<script src="../search/main.js"></script>
<script src="../js/gitbook.min.js"></script>
<script src="../js/theme.min.js"></script>
</body>
</html>